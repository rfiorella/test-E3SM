#!/usr/bin/env python
from standard_script_setup import *
from CIME.utils import run_cmd_no_fail
from CIME.case import Case

logger = logging.getLogger(__name__)

def parse_command_line(args, description):
###############################################################################
    parser = argparse.ArgumentParser(
        usage="""\n{0} [--debug]
OR
{0} --verbose
OR
{0} --help
OR
{0} --test

\033[1mEXAMPLES:\033[0m
    \033[1;32m# Run \033[0m
    > {0}
""" .format (os.path.basename(args[0])),

description=description,

formatter_class=argparse.ArgumentDefaultsHelpFormatter
)

    CIME.utils.setup_standard_logging_options(parser)

    parser.add_argument("buildroot",
                        help="build path root")

    parser.add_argument("installpath",
                        help="install path ")

    parser.add_argument("caseroot", nargs="?", default=os.getcwd(),
                        help="Case directory to build")

    args = CIME.utils.parse_args_and_handle_standard_logging_options(args, parser)

    return args.buildroot, args.installpath, args.caseroot

def file_len(fname):
    i = 0
    with open(fname) as f:
        for i in enumerate(f):
            pass
    return i + 1

def buildlib(bldroot, installpath, caseroot):
###############################################################################
    with Case(caseroot, read_only=False) as case:
        cimeroot = case.get_value("CIMEROOT")
        filepath = [os.path.join(caseroot,"SourceMods","src.share"),
                    os.path.join(cimeroot,"src","drivers","mct","shr"),
                    os.path.join(cimeroot,"src","components","xcpl_models","xshare"),
                    os.path.join(cimeroot,"src","share","streams"),
                    os.path.join(cimeroot,"src","share","util"),
                    os.path.join(cimeroot,"src","share","RandNum","src"),
                    os.path.join(cimeroot,"src","share","RandNum","src","dsfmt_f03"),
                    os.path.join(cimeroot,"src","share","RandNum","src","kissvec"),
                    os.path.join(cimeroot,"src","share","RandNum","src","mt19937")]
        if case.get_value("USE_ESMF_LIB"):
            use_esmf = "esmf"
            filepath.append(os.path.join(cimeroot, "src", "share", "esmf_wrf_timemgr"))
        else:
            use_esmf = "noesmf"
            filepath.append(os.path.join(cimeroot, "src", "share", "shr_esmf"))
        
        comp_interface = case.get_value("COMP_INTERFACE")
        ninst_value = case.get_value("NINST_VALUE")
        installdir = os.path.join(installpath, comp_interface, 
                                  ninst_value, use_esmf)
        libdir = os.path.join(bldroot,comp_interface,ninst_value,use_esmf,"csm_share")
        if not os.path.isdir(libdir):
            os.makedirs(libdir)

        filepathfile = os.path.join(libdir, "Filepath")
        # if the filepathfile has a different number of lines than filepath, replace it
        if os.path.isfile(filepathfile) and len(filepath) != file_len(filepathfile):
            with open(filepathfile, "w") as fd:
                for path in filepath:
                    fd.write(path)
        
        components = case.get_values("COMP_CLASSES")
        multiinst_cppdefs = ""
        for comp in components:
            if comp == "CPL":
                continue
            ninst_comp = case.get_value("NINST_{}".format(comp))
            multiinst_cppdefs += " -DNUM_COMP_INST_{}={}".format(comp, ninst_comp)

        gmake_opts = "-f {}/Makefile MODEL=csm_share ".format(os.path.join(caseroot,"Tools"))
        gmake_opts += "-j {} ".format(case.get_value("GMAKE_J"))
        gmake_opts += " COMPLIB=libcsm_share.a "
        gmake_opts += " USER_CPPDEFS=\"{}\" ".format(multiinst_cppdefs)
        gmake_opts += " -C {}".format(installdir)

        gmake_cmd = case.get_value("GMAKE")
        
        # This runs the gptl make command
        cmd = "{} {}".format(gmake_cmd, gmake_opts)
        output = run_cmd_no_fail(cmd)
        logger.info(output)

def _main(argv, documentation):
    bldroot, installpath, caseroot = parse_command_line(argv, documentation)
    buildlib(bldroot, installpath, caseroot)


if (__name__ == "__main__"):
    if ("--test" in sys.argv):
        test_results = doctest.testmod(verbose=True)
        sys.exit(1 if test_results.failed > 0 else 0)
    _main(sys.argv, __doc__)
