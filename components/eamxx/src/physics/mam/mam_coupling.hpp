#ifndef MAM_COUPLING_HPP
#define MAM_COUPLING_HPP

#include <mam4xx/mam4.hpp>
#include <ekat/kokkos/ekat_subview_utils.hpp>

// These data structures and functions are used to move data between EAMxx
// and mam4xx. This file must be adjusted whenever the aerosol modes and
// species are modified.

namespace scream::mam_coupling {

using KT            = ekat::KokkosTypes<ekat::DefaultDevice>;

// views for single- and multi-column data
using view_1d       = typename KT::template view_1d<Real>;
using view_2d       = typename KT::template view_2d<Real>;
using const_view_1d = typename KT::template view_1d<const Real>;
using const_view_2d = typename KT::template view_2d<const Real>;

// unmanaged views (for buffer and workspace manager)
using uview_1d = typename ekat::template Unmanaged<typename KT::template view_1d<Real>>;
using uview_2d = typename ekat::template Unmanaged<typename KT::template view_2d<Real>>;

// returns the number of distinct aerosol modes
KOKKOS_INLINE_FUNCTION
constexpr int num_aero_modes() {
  return mam4::AeroConfig::num_modes();
}

// returns the number of distinct aerosol species
KOKKOS_INLINE_FUNCTION
constexpr int num_aero_species() {
  return mam4::AeroConfig::num_aerosol_ids();
}

// returns the number of distinct aerosol-related gases
KOKKOS_INLINE_FUNCTION
constexpr int num_aero_gases() {
  return mam4::AeroConfig::num_gas_ids();
}

// returns the total number of aerosol tracers (i.e. the total number of
// distinct valid mode-species pairs)
KOKKOS_INLINE_FUNCTION
constexpr int num_aero_tracers() {
  // see mam4::mode_aero_species() for valid per-mode aerosol species
  // (in mam4xx/aero_modes.hpp)
  return 7 + 4 + 7 + 3;
}


// Given a MAM aerosol mode index, returns a string denoting the symbolic
// name of the mode.
KOKKOS_INLINE_FUNCTION
const char* aero_mode_name(const int mode) {
  static const char *mode_names[num_aero_modes()] = {
    "accum",
    "aitken",
    "coarse",
    "primary_carbon",
  };
  return mode_names[mode];
}

// Given a MAM aerosol species ID, returns a string denoting the symbolic
// name of the species.
KOKKOS_INLINE_FUNCTION
const char* aero_species_name(const int species_id) {
  static const char *species_names[num_aero_species()] = {
    "soa",
    "so4",
    "pom",
    "bc",
    "nacl",
    "dst",
    "mom",
  };
  return species_names[species_id];
}

// Given a MAM aerosol-related gas ID, returns a string denoting the symbolic
// name of the gas species.
KOKKOS_INLINE_FUNCTION
const char* gas_species_name(const int gas_id) {
  static const char *species_names[num_aero_gases()] = {
    "soag",
    "h2so4",
    "nh3",
  };
  return species_names[gas_id];
}

// here we provide storage for names of fields generated by the functions below
namespace {

constexpr int max_field_name_len_ = 128;

char int_aero_nmr_names_[num_aero_modes()][max_field_name_len_] = {};
char cld_aero_nmr_names_[num_aero_modes()][max_field_name_len_] = {};
char int_aero_mmr_names_[num_aero_modes()][num_aero_species()][max_field_name_len_] = {};
char cld_aero_mmr_names_[num_aero_modes()][num_aero_species()][max_field_name_len_] = {};
char gas_mmr_names_[num_aero_gases()][max_field_name_len_] = {};

}

// Given a MAM aerosol mode index, returns the name of the related interstitial
// modal number mixing ratio field in EAMxx ("int_aero_nmr_<mode>")
KOKKOS_INLINE_FUNCTION
const char* int_aero_nmr_field_name(const int mode) {
  if (!int_aero_nmr_names_[mode]) {
    strcpy(int_aero_nmr_names_[mode], "int_aero_nmr_");
    strcat(int_aero_nmr_names_[mode], aero_mode_name(mode));
  }
  return const_cast<const char*>(int_aero_nmr_names_[mode]);
}

// Given a MAM aerosol mode index, returns the name of the related cloudborne
// modal number mixing ratio field in EAMxx ("cld_aero_nmr_<mode>")
KOKKOS_INLINE_FUNCTION
const char* cld_aero_nmr_field_name(const int mode) {
  if (!cld_aero_nmr_names_[mode]) {
    strcpy(cld_aero_nmr_names_[mode], "int_aero_nmr_");
    strcat(cld_aero_nmr_names_[mode], aero_mode_name(mode));
  }
  return const_cast<const char*>(cld_aero_nmr_names_[mode]);
}

// Given a MAM aerosol mode index and the index of the MAM aerosol species
// within it, returns the name of the relevant interstitial mass mixing ratio
// field in EAMxx. The form of the field name is "int_aero_mmr_<mode>_<species>".
// If the desired species is not present within the desire mode, returns a blank
// string ("").
KOKKOS_INLINE_FUNCTION
const char* int_aero_mmr_field_name(const int mode, const int species) {
  if (!int_aero_mmr_names_[mode][species]) {
    const auto aero_id = mam4::mode_aero_species(mode, species);
    if (aero_id != mam4::AeroId::None) {
      strcpy(int_aero_mmr_names_[mode][species], "int_aero_mmr_");
      strcat(int_aero_mmr_names_[mode][species], aero_mode_name(mode));
      strcat(int_aero_mmr_names_[mode][species], aero_species_name(static_cast<int>(aero_id)));
    } else {
      int_aero_mmr_names_[mode][species][0] = 0;
    }
  }
  return const_cast<const char*>(int_aero_mmr_names_[mode][species]);
};

// Given a MAM aerosol mode index and the index of the MAM aerosol species
// within it, returns the name of the relevant cloudborne mass mixing ratio
// field in EAMxx. The form of the field name is "cld_aero_mmr_<mode>_<species>".
// If the desired species is not present within the desire mode, returns a blank
// string ("").
KOKKOS_INLINE_FUNCTION
const char* cld_aero_mmr_field_name(const int mode, const int species) {
  if (!cld_aero_mmr_names_[mode][species]) {
    const auto aero_id = mam4::mode_aero_species(mode, species);
    if (aero_id != mam4::AeroId::None) {
      strcpy(cld_aero_mmr_names_[mode][species], "cld_aero_mmr_");
      strcat(cld_aero_mmr_names_[mode][species], aero_mode_name(mode));
      strcat(cld_aero_mmr_names_[mode][species], aero_species_name(static_cast<int>(aero_id)));
    } else {
      cld_aero_mmr_names_[mode][species][0] = 0;
    }
  }
  return const_cast<const char*>(cld_aero_mmr_names_[mode][species]);
};

// Given a MAM aerosol-related gas identifier, returns the name of its mass
// mixing ratio field in EAMxx ("aero_gas_mmr_<gas>")
KOKKOS_INLINE_FUNCTION
constexpr const char* gas_mmr_field_name(const int gas) {
  if (!gas_mmr_names_[gas]) {
    strcpy(gas_mmr_names_[gas], "aero_gas_mmr_");
    strcat(gas_mmr_names_[gas], gas_species_name(gas));
  }
  return const_cast<const char*>(gas_mmr_names_[gas]);
}

// This type stores views related to the atmospheric state used by MAM. It has
// wet and dry representations of tracer variables, as well as a simple height
// coordinate.
struct AtmosphericState {
  const_view_2d T_mid;     // temperature at grid midpoints [K]
  const_view_2d p_mid;     // total pressure at grid midpoints [Pa]
  const_view_2d qv_wet;    // wet water vapor specific humidity [kg vapor / kg moist air]
  view_2d       qv_dry;    // dry water vapor mixing ratio [kg vapor / kg dry air]
  const_view_2d qc_wet;    // wet cloud liquid water mass mixing ratio [kg cloud water/kg moist air]
  view_2d       qc_dry;    // dry cloud liquid water mass mixing ratio [kg cloud water/kg dry air]
  const_view_2d nc_wet;    // wet cloud liquid water number mixing ratio [# / kg moist air]
  view_2d       nc_dry;    // dry cloud liquid water number mixing ratio [# / kg dry air]
  const_view_2d qi_wet;    // wet cloud ice water mass mixing ratio [kg cloud ice water / kg moist air]
  view_2d       qi_dry;    // dry cloud ice water mass mixing ratio [kg cloud ice water / kg dry air]
  const_view_2d ni_wet;    // wet cloud ice water number mixing ratio [# / kg moist air]
  view_2d       ni_dry;    // dry cloud ice water number mixing ratio [# / kg dry air]
  view_2d       z_mid;     // height at layer midpoints [m]
  view_2d       z_iface;   // height at layer interfaces [m]
  view_2d       dz;        // layer thickness [m]
  const_view_2d pdel;      // hydrostatic "pressure thickness" at grid interfaces [Pa]
  const_view_2d cldfrac;   // cloud fraction [-]
  const_view_2d omega;     // vertical pressure velocity [Pa/s]
  view_2d       w_updraft; // updraft velocity [m/s]
  const_view_1d pblh;      // planetary boundary layer height [m]
};

// This type stores aerosol number and mass mixing ratios evolved by MAM. It
// has wet and dry representations of each quantity. These quantities are stored
// by mode (and species, for mass mixing ratio) in the same way as they are in
// mam4xx, and indexed using mam4::AeroConfig.
struct AerosolState {
  view_2d wet_int_aero_nmr[num_aero_modes()]; // wet modal interstitial aerosol number mixing ratios [# / kg moist air]
  view_2d wet_cld_aero_nmr[num_aero_modes()]; // wet modal cloudborne aerosol number mixing ratios [# / kg moist air]
  view_2d dry_int_aero_nmr[num_aero_modes()]; // dry modal interstitial aerosol number mixing ratios [# / kg dry air]
  view_2d dry_cld_aero_nmr[num_aero_modes()]; // dry modal cloudborne aerosol number mixing ratios [# / kg dry air]
  view_2d wet_int_aero_mmr[num_aero_modes()][num_aero_species()]; // wet interstitial aerosol mass mixing ratios [kg aerosol / kg moist air]
  view_2d wet_cld_aero_mmr[num_aero_modes()][num_aero_species()]; // wet cloudborne aerosol mass mixing ratios [kg aerosol / kg moist air]
  view_2d dry_int_aero_mmr[num_aero_modes()][num_aero_species()]; // dry interstitial aerosol mass mixing ratios [kg aerosol / kg dry air]
  view_2d dry_cld_aero_mmr[num_aero_modes()][num_aero_species()]; // dry cloudborne aerosol mass mixing ratios [kg aerosol / kg dry air]
  view_2d wet_gas_mmr[num_aero_gases()]; // wet gas mass mixing ratios [kg gas / kg moist air]
  view_2d dry_gas_mmr[num_aero_gases()]; // dry gas mass mixing ratios [kg gas / kg dry air]
};

// storage for variables used within MAM atmosphere processes, initialized with
// ATMBufferManager
struct Buffer {
  // number of local fields stored at column midpoints
  static constexpr int num_2d_mid = 8 + num_aero_modes() + 2 * num_aero_tracers() +
                                    num_aero_gases();

  // ======================
  // column midpoint fields
  // ======================

  // (dry) atmospheric state
  uview_2d z_mid;             // height at midpoints
  uview_2d dz;                // layer thickness
  uview_2d qv_dry;            // dry water vapor mixing ratio (dry air)
  uview_2d qc_dry;            // dry cloud water mass mixing ratio
  uview_2d nc_dry;            // dry cloud water number mixing ratio
  uview_2d qi_dry;            // cloud ice mass mixing ratio
  uview_2d ni_dry;            // dry cloud ice number mixing ratio
  uview_2d w_updraft;         // vertical wind velocity

  // aerosol dry interstitial/cloudborne number/mass mixing ratios
  uview_2d dry_int_aero_nmr[num_aero_modes()];
  uview_2d dry_cld_aero_nmr[num_aero_modes()];
  uview_2d dry_int_aero_mmr[num_aero_modes()][num_aero_species()];
  uview_2d dry_cld_aero_mmr[num_aero_modes()][num_aero_species()];

  // aerosol-related dry gas mass mixing ratios
  uview_2d dry_gas_mmr[num_aero_gases()];

  // number of local fields stored at column interfaces
  static constexpr int num_2d_iface = 1;

  // =======================
  // column interface fields
  // =======================

  uview_2d z_iface; // height at interfaces

  // storage
  Real* wsm_data;
};

// Given a mam_coupling::AtmosphericState with views for wet and dry quantities,
// creates a haero::Atmosphere object for the column with the given index. This
// object can be provided to mam4xx for the column.
KOKKOS_INLINE_FUNCTION
haero::Atmosphere atmosphere_for_column(const AtmosphericState& atm_state,
                                        int column_index) {
  EKAT_KERNEL_ASSERT_MSG(atm_state.T_mid.data() != nullptr,
    "T_mid not defined for atmospheric state!");
  EKAT_KERNEL_ASSERT_MSG(atm_state.p_mid.data() != nullptr,
    "p_mid not defined for atmospheric state!");
  EKAT_KERNEL_ASSERT_MSG(atm_state.qv_dry.data() != nullptr,
    "qv_dry not defined for atmospheric state!");
  EKAT_KERNEL_ASSERT_MSG(atm_state.qc_dry.data() != nullptr,
    "qc_dry not defined for atmospheric state!");
  EKAT_KERNEL_ASSERT_MSG(atm_state.nc_dry.data() != nullptr,
    "nc_dry not defined for atmospheric state!");
  EKAT_KERNEL_ASSERT_MSG(atm_state.qi_dry.data() != nullptr,
    "qi_dry not defined for atmospheric state!");
  EKAT_KERNEL_ASSERT_MSG(atm_state.ni_dry.data() != nullptr,
    "ni_dry not defined for atmospheric state!");
  EKAT_KERNEL_ASSERT_MSG(atm_state.z_mid.data() != nullptr,
    "z_mid not defined for atmospheric state!");
  EKAT_KERNEL_ASSERT_MSG(atm_state.pdel.data() != nullptr,
    "pdel not defined for atmospheric state!");
  EKAT_KERNEL_ASSERT_MSG(atm_state.cldfrac.data() != nullptr,
    "cldfrac not defined for atmospheric state!");
  EKAT_KERNEL_ASSERT_MSG(atm_state.w_updraft.data() != nullptr,
    "w_updraft not defined for atmospheric state!");
  return haero::Atmosphere(mam4::nlev,
                           ekat::subview(atm_state.T_mid, column_index),
                           ekat::subview(atm_state.p_mid, column_index),
                           ekat::subview(atm_state.qv_dry, column_index),
                           ekat::subview(atm_state.qc_dry, column_index),
                           ekat::subview(atm_state.nc_dry, column_index),
                           ekat::subview(atm_state.qi_dry, column_index),
                           ekat::subview(atm_state.ni_dry, column_index),
                           ekat::subview(atm_state.z_mid, column_index),
                           ekat::subview(atm_state.pdel, column_index),
                           ekat::subview(atm_state.cldfrac, column_index),
                           ekat::subview(atm_state.w_updraft, column_index),
                           atm_state.pblh(column_index));
}

// Given a mam_coupling::AerosolState with views for wet and dry quantities,
// creates a mam4::Prognostics object for the column with the given index with
// ONLY INTERSTITIAL AEROSOL VIEWS DEFINED. This object can be provided to
// mam4xx for the column.
KOKKOS_INLINE_FUNCTION
mam4::Prognostics interstitial_aerosols_for_column(const AerosolState& aero_state,
                                                   int column_index) {
  mam4::Prognostics progs(mam4::nlev);
  for (int m = 0; m < mam_coupling::num_aero_modes(); ++m) {
    EKAT_KERNEL_ASSERT_MSG(aero_state.dry_int_aero_nmr[m].data() != nullptr,
      "dry_int_aero_nmr not defined for aerosol state!");
    progs.n_mode_i[m] = ekat::subview(aero_state.dry_int_aero_nmr[m], column_index);
    for (int a = 0; a < mam_coupling::num_aero_species(); ++a) {
      if (aero_state.dry_int_aero_mmr[m][a].data()) {
        progs.q_aero_i[m][a] = ekat::subview(aero_state.dry_int_aero_mmr[m][a], column_index);
      }
    }
  }
  for (int g = 0; g < mam_coupling::num_aero_gases(); ++g) {
    EKAT_KERNEL_ASSERT_MSG(aero_state.dry_gas_mmr[g].data() != nullptr,
      "dry_gas_mmr not defined for aerosol state!");
    progs.q_gas[g] = ekat::subview(aero_state.dry_gas_mmr[g], column_index);
  }
  return progs;
}

// Given a mam_coupling::AerosolState with views for wet and dry quantities,
// creates a mam4::Prognostics object for the column with the given index with
// interstitial and cloudborne aerosol views defined. This object can be
// provided to mam4xx for the column.
KOKKOS_INLINE_FUNCTION
mam4::Prognostics aerosols_for_column(const AerosolState& aero_state,
                                      int column_index) {
  auto progs = interstitial_aerosols_for_column(aero_state, column_index);
  for (int m = 0; m < mam_coupling::num_aero_modes(); ++m) {
    EKAT_KERNEL_ASSERT_MSG(aero_state.dry_cld_aero_nmr[m].data() != nullptr,
      "dry_cld_aero_nmr not defined for aerosol state!");
    progs.n_mode_c[m] = ekat::subview(aero_state.dry_cld_aero_nmr[m], column_index);
    for (int a = 0; a < mam_coupling::num_aero_species(); ++a) {
      if (aero_state.dry_cld_aero_mmr[m][a].data()) {
        progs.q_aero_c[m][a] = ekat::subview(aero_state.dry_cld_aero_mmr[m][a], column_index);
      }
    }
  }
  return progs;
}

} // namespace scream::mam_coupling

#endif
