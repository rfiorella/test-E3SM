#ifndef MAM_COUPLING_HPP
#define MAM_COUPLING_HPP

#include <mam4xx/mam4.hpp>
#include <ekat/kokkos/ekat_subview_utils.hpp>
#include <share/util/scream_common_physics_functions.hpp>

// These data structures and functions are used to move data between EAMxx
// and mam4xx. This file must be adjusted whenever the aerosol modes and
// species are modified.

namespace scream::mam_coupling {

using KT            = ekat::KokkosTypes<ekat::DefaultDevice>;

// views for single- and multi-column data
using view_1d       = typename KT::template view_1d<Real>;
using view_2d       = typename KT::template view_2d<Real>;
using const_view_1d = typename KT::template view_1d<const Real>;
using const_view_2d = typename KT::template view_2d<const Real>;

// Kokkos thread team (league member)
using Team = Kokkos::TeamPolicy<KT::ExeSpace>::member_type;

// unmanaged views (for buffer and workspace manager)
using uview_1d = typename ekat::template Unmanaged<typename KT::template view_1d<Real>>;
using uview_2d = typename ekat::template Unmanaged<typename KT::template view_2d<Real>>;

using PF = scream::PhysicsFunctions<DefaultDevice>;

// returns the number of distinct aerosol modes
KOKKOS_INLINE_FUNCTION
constexpr int num_aero_modes() {
  return mam4::AeroConfig::num_modes();
}

// returns the number of distinct aerosol species
KOKKOS_INLINE_FUNCTION
constexpr int num_aero_species() {
  return mam4::AeroConfig::num_aerosol_ids();
}

// returns the number of distinct aerosol-related gases
KOKKOS_INLINE_FUNCTION
constexpr int num_aero_gases() {
  return mam4::AeroConfig::num_gas_ids();
}

// returns the total number of aerosol tracers (i.e. the total number of
// distinct valid mode-species pairs)
KOKKOS_INLINE_FUNCTION
constexpr int num_aero_tracers() {
  // see mam4::mode_aero_species() for valid per-mode aerosol species
  // (in mam4xx/aero_modes.hpp)
  return 7 + 4 + 7 + 3;
}


// Given a MAM aerosol mode index, returns a string denoting the symbolic
// name of the mode.
KOKKOS_INLINE_FUNCTION
const char* aero_mode_name(const int mode) {
  static const char *mode_names[num_aero_modes()] = {
    "accum",
    "aitken",
    "coarse",
    "primary_carbon",
  };
  return mode_names[mode];
}

// Given a MAM aerosol species ID, returns a string denoting the symbolic
// name of the species.
KOKKOS_INLINE_FUNCTION
const char* aero_species_name(const int species_id) {
  static const char *species_names[num_aero_species()] = {
    "soa",
    "so4",
    "pom",
    "bc",
    "nacl",
    "dst",
    "mom",
  };
  return species_names[species_id];
}

// Given a MAM aerosol-related gas ID, returns a string denoting the symbolic
// name of the gas species.
KOKKOS_INLINE_FUNCTION
const char* gas_species_name(const int gas_id) {
  static const char *species_names[num_aero_gases()] = {
    "soag",
    "h2so4",
    "nh3",
  };
  return species_names[gas_id];
}

// here we provide storage for names of fields generated by the functions below
namespace {

constexpr int max_field_name_len_ = 128;

char int_aero_nmr_names_[num_aero_modes()][max_field_name_len_] = {};
char cld_aero_nmr_names_[num_aero_modes()][max_field_name_len_] = {};
char int_aero_mmr_names_[num_aero_modes()][num_aero_species()][max_field_name_len_] = {};
char cld_aero_mmr_names_[num_aero_modes()][num_aero_species()][max_field_name_len_] = {};
char gas_mmr_names_[num_aero_gases()][max_field_name_len_] = {};

}

// Given a MAM aerosol mode index, returns the name of the related interstitial
// modal number mixing ratio field in EAMxx ("int_aero_nmr_<mode>")
KOKKOS_INLINE_FUNCTION
const char* int_aero_nmr_field_name(const int mode) {
  if (!int_aero_nmr_names_[mode]) {
    strcpy(int_aero_nmr_names_[mode], "int_aero_nmr_");
    strcat(int_aero_nmr_names_[mode], aero_mode_name(mode));
  }
  return const_cast<const char*>(int_aero_nmr_names_[mode]);
}

// Given a MAM aerosol mode index, returns the name of the related cloudborne
// modal number mixing ratio field in EAMxx ("cld_aero_nmr_<mode>")
KOKKOS_INLINE_FUNCTION
const char* cld_aero_nmr_field_name(const int mode) {
  if (!cld_aero_nmr_names_[mode]) {
    strcpy(cld_aero_nmr_names_[mode], "int_aero_nmr_");
    strcat(cld_aero_nmr_names_[mode], aero_mode_name(mode));
  }
  return const_cast<const char*>(cld_aero_nmr_names_[mode]);
}

// Given a MAM aerosol mode index and the index of the MAM aerosol species
// within it, returns the name of the relevant interstitial mass mixing ratio
// field in EAMxx. The form of the field name is "int_aero_mmr_<mode>_<species>".
// If the desired species is not present within the desire mode, returns a blank
// string ("").
KOKKOS_INLINE_FUNCTION
const char* int_aero_mmr_field_name(const int mode, const int species) {
  if (!int_aero_mmr_names_[mode][species]) {
    const auto aero_id = mam4::mode_aero_species(mode, species);
    if (aero_id != mam4::AeroId::None) {
      strcpy(int_aero_mmr_names_[mode][species], "int_aero_mmr_");
      strcat(int_aero_mmr_names_[mode][species], aero_mode_name(mode));
      strcat(int_aero_mmr_names_[mode][species], aero_species_name(static_cast<int>(aero_id)));
    } else {
      int_aero_mmr_names_[mode][species][0] = 0;
    }
  }
  return const_cast<const char*>(int_aero_mmr_names_[mode][species]);
};

// Given a MAM aerosol mode index and the index of the MAM aerosol species
// within it, returns the name of the relevant cloudborne mass mixing ratio
// field in EAMxx. The form of the field name is "cld_aero_mmr_<mode>_<species>".
// If the desired species is not present within the desire mode, returns a blank
// string ("").
KOKKOS_INLINE_FUNCTION
const char* cld_aero_mmr_field_name(const int mode, const int species) {
  if (!cld_aero_mmr_names_[mode][species]) {
    const auto aero_id = mam4::mode_aero_species(mode, species);
    if (aero_id != mam4::AeroId::None) {
      strcpy(cld_aero_mmr_names_[mode][species], "cld_aero_mmr_");
      strcat(cld_aero_mmr_names_[mode][species], aero_mode_name(mode));
      strcat(cld_aero_mmr_names_[mode][species], aero_species_name(static_cast<int>(aero_id)));
    } else {
      cld_aero_mmr_names_[mode][species][0] = 0;
    }
  }
  return const_cast<const char*>(cld_aero_mmr_names_[mode][species]);
};

// Given a MAM aerosol-related gas identifier, returns the name of its mass
// mixing ratio field in EAMxx ("aero_gas_mmr_<gas>")
KOKKOS_INLINE_FUNCTION
constexpr const char* gas_mmr_field_name(const int gas) {
  if (!gas_mmr_names_[gas]) {
    strcpy(gas_mmr_names_[gas], "aero_gas_mmr_");
    strcat(gas_mmr_names_[gas], gas_species_name(gas));
  }
  return const_cast<const char*>(gas_mmr_names_[gas]);
}

// This type stores multi-column views related specifically to the wet
// atmospheric state used by EAMxx.
struct WetAtmosphere {
  const_view_2d qv;      // wet water vapor specific humidity [kg vapor / kg moist air]
  const_view_2d qc;      // wet cloud liquid water mass mixing ratio [kg cloud water/kg moist air]
  const_view_2d nc;      // wet cloud liquid water number mixing ratio [# / kg moist air]
  const_view_2d qi;      // wet cloud ice water mass mixing ratio [kg cloud ice water / kg moist air]
  const_view_2d ni;      // wet cloud ice water number mixing ratio [# / kg moist air]
  const_view_2d omega;   // vertical pressure velocity [Pa/s]
};

// This type stores multi-column views related to the dry atmospheric state
// used by MAM.
struct DryAtmosphere {
  Real          z_surf;    // height of bottom of atmosphere [m]
  const_view_2d T_mid;     // temperature at grid midpoints [K]
  const_view_2d p_mid;     // total pressure at grid midpoints [Pa]
  view_2d       qv;        // dry water vapor mixing ratio [kg vapor / kg dry air]
  view_2d       qc;        // dry cloud liquid water mass mixing ratio [kg cloud water/kg dry air]
  view_2d       nc;        // dry cloud liquid water number mixing ratio [# / kg dry air]
  view_2d       qi;        // dry cloud ice water mass mixing ratio [kg cloud ice water / kg dry air]
  view_2d       ni;        // dry cloud ice water number mixing ratio [# / kg dry air]
  view_2d       z_mid;     // height at layer midpoints [m]
  view_2d       z_iface;   // height at layer interfaces [m]
  view_2d       dz;        // layer thickness [m]
  const_view_2d p_del;     // hydrostatic "pressure thickness" at grid interfaces [Pa]
  const_view_2d cldfrac;   // cloud fraction [-]
  view_2d       w_updraft; // updraft velocity [m/s]
  const_view_1d pblh;      // planetary boundary layer height [m]
};

// This type stores aerosol number and mass mixing ratios evolved by MAM. It
// can be used to represent wet and dry aerosols. When you declare an
// AerosolState, you must decide whether it's a dry or wet aerosol state (with
// mixing ratios in terms of dry or wet parcels of air, respectively).
// These mixing ratios are organized by mode (and species, for mass mixing ratio)
// in the same way as they are in mam4xx, and indexed using mam4::AeroConfig.
struct AerosolState {
  view_2d int_aero_nmr[num_aero_modes()]; // modal interstitial aerosol number mixing ratios [# / kg air]
  view_2d cld_aero_nmr[num_aero_modes()]; // modal cloudborne aerosol number mixing ratios [# / kg air]
  view_2d int_aero_mmr[num_aero_modes()][num_aero_species()]; // interstitial aerosol mass mixing ratios [kg aerosol / kg air]
  view_2d cld_aero_mmr[num_aero_modes()][num_aero_species()]; // cloudborne aerosol mass mixing ratios [kg aerosol / kg air]
  view_2d gas_mmr[num_aero_gases()]; // gas mass mixing ratios [kg gas / kg air]
};

// storage for variables used within MAM atmosphere processes, initialized with
// ATMBufferManager
struct Buffer {
  // ======================
  // column midpoint fields
  // ======================

  // number of local fields stored at column midpoints
  static constexpr int num_2d_mid = 8 + // number of dry atm fields
                                    num_aero_modes() +
                                2 * num_aero_tracers() + // interstitial + cloudborne
                                    num_aero_gases();

  // (dry) atmospheric state
  uview_2d z_mid;             // height at midpoints
  uview_2d dz;                // layer thickness
  uview_2d qv_dry;            // dry water vapor mixing ratio (dry air)
  uview_2d qc_dry;            // dry cloud water mass mixing ratio
  uview_2d nc_dry;            // dry cloud water number mixing ratio
  uview_2d qi_dry;            // cloud ice mass mixing ratio
  uview_2d ni_dry;            // dry cloud ice number mixing ratio
  uview_2d w_updraft;         // vertical wind velocity

  // aerosol dry interstitial/cloudborne number/mass mixing ratios
  uview_2d dry_int_aero_nmr[num_aero_modes()];
  uview_2d dry_cld_aero_nmr[num_aero_modes()];
  uview_2d dry_int_aero_mmr[num_aero_modes()][num_aero_species()];
  uview_2d dry_cld_aero_mmr[num_aero_modes()][num_aero_species()];

  // aerosol-related dry gas mass mixing ratios
  uview_2d dry_gas_mmr[num_aero_gases()];

  // =======================
  // column interface fields
  // =======================

  // number of local fields stored at column interfaces
  static constexpr int num_2d_iface = 1;

  uview_2d z_iface; // height at interfaces

  // storage
  Real* wsm_data;
};

// Given a dry atmosphere state, creates a haero::Atmosphere object for the
// column with the given index. This object can be provided to mam4xx for the
// column.
KOKKOS_INLINE_FUNCTION
haero::Atmosphere atmosphere_for_column(const DryAtmosphere& dry_atm,
                                        const int column_index) {
  EKAT_KERNEL_ASSERT_MSG(dry_atm.T_mid.data() != nullptr,
    "T_mid not defined for dry atmosphere state!");
  EKAT_KERNEL_ASSERT_MSG(dry_atm.p_mid.data() != nullptr,
    "p_mid not defined for dry atmosphere state!");
  EKAT_KERNEL_ASSERT_MSG(dry_atm.qv.data() != nullptr,
    "qv not defined for dry atmosphere state!");
  EKAT_KERNEL_ASSERT_MSG(dry_atm.qc.data() != nullptr,
    "qc not defined for dry atmosphere state!");
  EKAT_KERNEL_ASSERT_MSG(dry_atm.nc.data() != nullptr,
    "nc not defined for dry atmosphere state!");
  EKAT_KERNEL_ASSERT_MSG(dry_atm.qi.data() != nullptr,
    "qi not defined for dry atmosphere state!");
  EKAT_KERNEL_ASSERT_MSG(dry_atm.ni.data() != nullptr,
    "ni not defined for dry atmosphere state!");
  EKAT_KERNEL_ASSERT_MSG(dry_atm.z_mid.data() != nullptr,
    "z_mid not defined for dry atmosphere state!");
  EKAT_KERNEL_ASSERT_MSG(dry_atm.p_del.data() != nullptr,
    "p_del not defined for dry atmosphere state!");
  EKAT_KERNEL_ASSERT_MSG(dry_atm.cldfrac.data() != nullptr,
    "cldfrac not defined for dry atmosphere state!");
  EKAT_KERNEL_ASSERT_MSG(dry_atm.w_updraft.data() != nullptr,
    "w_updraft not defined for dry atmosphere state!");
  return haero::Atmosphere(mam4::nlev,
                           ekat::subview(dry_atm.T_mid, column_index),
                           ekat::subview(dry_atm.p_mid, column_index),
                           ekat::subview(dry_atm.qv, column_index),
                           ekat::subview(dry_atm.qc, column_index),
                           ekat::subview(dry_atm.nc, column_index),
                           ekat::subview(dry_atm.qi, column_index),
                           ekat::subview(dry_atm.ni, column_index),
                           ekat::subview(dry_atm.z_mid, column_index),
                           ekat::subview(dry_atm.p_del, column_index),
                           ekat::subview(dry_atm.cldfrac, column_index),
                           ekat::subview(dry_atm.w_updraft, column_index),
                           dry_atm.pblh(column_index));
}

// Given a mam_coupling::AerosolState with views for wet and dry quantities,
// creates a mam4::Prognostics object for the column with the given index with
// ONLY INTERSTITIAL AEROSOL VIEWS DEFINED. This object can be provided to
// mam4xx for the column.
KOKKOS_INLINE_FUNCTION
mam4::Prognostics interstitial_aerosols_for_column(const AerosolState& dry_aero,
                                                   const int column_index) {
  mam4::Prognostics progs(mam4::nlev);
  for (int m = 0; m < mam_coupling::num_aero_modes(); ++m) {
    EKAT_KERNEL_ASSERT_MSG(dry_aero.int_aero_nmr[m].data(),
      "int_aero_nmr not defined for dry aerosol state!");
    progs.n_mode_i[m] = ekat::subview(dry_aero.int_aero_nmr[m], column_index);
    for (int a = 0; a < mam_coupling::num_aero_species(); ++a) {
      if (dry_aero.int_aero_mmr[m][a].data()) {
        progs.q_aero_i[m][a] = ekat::subview(dry_aero.int_aero_mmr[m][a], column_index);
      }
    }
  }
  for (int g = 0; g < mam_coupling::num_aero_gases(); ++g) {
    EKAT_KERNEL_ASSERT_MSG(dry_aero.gas_mmr[g].data(),
      "gas_mmr not defined for dry aerosol state!");
    progs.q_gas[g] = ekat::subview(dry_aero.gas_mmr[g], column_index);
  }
  return progs;
}

// Given a dry aerosol state, creates a mam4::Prognostics object for the column
// with the given index with interstitial and cloudborne aerosol views defined.
// This object can be provided to mam4xx for the column.
KOKKOS_INLINE_FUNCTION
mam4::Prognostics aerosols_for_column(const AerosolState& dry_aero,
                                      const int column_index) {
  auto progs = interstitial_aerosols_for_column(dry_aero, column_index);
  for (int m = 0; m < mam_coupling::num_aero_modes(); ++m) {
    EKAT_KERNEL_ASSERT_MSG(dry_aero.cld_aero_nmr[m].data(),
      "dry_cld_aero_nmr not defined for aerosol state!");
    progs.n_mode_c[m] = ekat::subview(dry_aero.cld_aero_nmr[m], column_index);
    for (int a = 0; a < mam_coupling::num_aero_species(); ++a) {
      if (dry_aero.cld_aero_mmr[m][a].data()) {
        progs.q_aero_c[m][a] = ekat::subview(dry_aero.cld_aero_mmr[m][a], column_index);
      }
    }
  }
  return progs;
}

// Given a thread team and a dry atmosphere state, dispatches threads from the
// team to compute vertical layer heights and interfaces for the column with
// the given index.
KOKKOS_INLINE_FUNCTION
void compute_vertical_layer_heights(const Team& team,
                                    const DryAtmosphere& dry_atm,
                                    const int column_index) {
  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(),
    "Given column index does not correspond to given team!");

  const auto dz = ekat::subview(dry_atm.dz, column_index);
  auto z_iface  = ekat::subview(dry_atm.z_iface, column_index);
  auto z_mid    = ekat::subview(dry_atm.z_mid, column_index);
  PF::calculate_z_int(team, mam4::nlev, dz, dry_atm.z_surf, z_iface);
  team.team_barrier(); // likely necessary to have z_iface up to date
  PF::calculate_z_mid(team, mam4::nlev, z_iface, z_mid);
}


// Given a thread team and a mam_coupling::AtmosphericState, dispatches threads
// from the team to compute the vertical updraft velocity for the column with
// the given index.
KOKKOS_INLINE_FUNCTION
void compute_updraft_velocities(const Team& team,
                                const WetAtmosphere& wet_atm,
                                const DryAtmosphere& dry_atm,
                                const int column_index) {
  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(),
    "Given column index does not correspond to given team!");

  int i = column_index;
  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, mam4::nlev), [&] (const int k) {
    const auto rho = PF::calculate_density(dry_atm.p_del(i,k), dry_atm.dz(i,k));
    dry_atm.w_updraft(i,k) = PF::calculate_vertical_velocity(wet_atm.omega(i,k), rho);
  });
}

// Given a thread team and a wet atmosphere state, dispatches threads
// from the team to compute mixing ratios for a dry atmosphere state in th
// column with the given index.
KOKKOS_INLINE_FUNCTION
void compute_dry_mixing_ratios(const Team& team,
                               const WetAtmosphere& wet_atm,
                               const DryAtmosphere& dry_atm,
                               const int column_index) {
  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(),
    "Given column index does not correspond to given team!");

  int i = column_index;
  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, mam4::nlev), [&] (const int k) {
    const auto qv_ik = wet_atm.qv(i,k);
    dry_atm.qv(i,k) = PF::calculate_drymmr_from_wetmmr(wet_atm.qv(i,k), qv_ik);
    dry_atm.qc(i,k) = PF::calculate_drymmr_from_wetmmr(wet_atm.qc(i,k), qv_ik);
    dry_atm.nc(i,k) = PF::calculate_drymmr_from_wetmmr(wet_atm.nc(i,k), qv_ik);
    dry_atm.qi(i,k) = PF::calculate_drymmr_from_wetmmr(wet_atm.qi(i,k), qv_ik);
    dry_atm.ni(i,k) = PF::calculate_drymmr_from_wetmmr(wet_atm.ni(i,k), qv_ik);
  });
}

// Given a thread team and wet atmospheric and aerosol states, dispatches threads
// from the team to compute mixing ratios for the given dry interstitial aerosol
// state for the column with the given index.
KOKKOS_INLINE_FUNCTION
void compute_dry_mixing_ratios(const Team& team,
                               const WetAtmosphere& wet_atm,
                               const AerosolState& wet_aero,
                               const AerosolState& dry_aero,
                               const int column_index) {
  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(),
    "Given column index does not correspond to given team!");

  int i = column_index;
  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, mam4::nlev), [&] (const int k) {
    const auto qv_ik = wet_atm.qv(i,k);
    for (int m = 0; m < mam_coupling::num_aero_modes(); ++m) {
      dry_aero.int_aero_nmr[m](i,k) = PF::calculate_drymmr_from_wetmmr(wet_aero.int_aero_nmr[m](i,k), qv_ik);
      if (dry_aero.cld_aero_nmr[m].data()) {
        dry_aero.cld_aero_nmr[m](i,k) = PF::calculate_drymmr_from_wetmmr(wet_aero.cld_aero_nmr[m](i,k), qv_ik);
      }
      for (int a = 0; a < mam_coupling::num_aero_species(); ++a) {
        if (dry_aero.int_aero_mmr[m][a].data()) {
          dry_aero.int_aero_mmr[m][a](i,k) = PF::calculate_drymmr_from_wetmmr(wet_aero.int_aero_mmr[m][a](i,k), qv_ik);
        }
        if (dry_aero.cld_aero_mmr[m][a].data()) {
          dry_aero.cld_aero_mmr[m][a](i,k) = PF::calculate_drymmr_from_wetmmr(wet_aero.cld_aero_mmr[m][a](i,k), qv_ik);
        }
      }
    }
    for (int g = 0; g < mam_coupling::num_aero_gases(); ++g) {
      dry_aero.gas_mmr[g](i,k) = PF::calculate_drymmr_from_wetmmr(wet_aero.gas_mmr[g](i,k), qv_ik);
    }
  });
}

// Given a thread team and dry atmospheric and aerosol states, dispatches threads
// from the team to compute mixing ratios for the given wet interstitial aerosol
// state for the column with the given index.
KOKKOS_INLINE_FUNCTION
void compute_wet_mixing_ratios(const Team& team,
                               const DryAtmosphere& dry_atm,
                               const AerosolState& dry_aero,
                               const AerosolState& wet_aero,
                               const int column_index) {
  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(),
    "Given column index does not correspond to given team!");

  int i = column_index;
  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, mam4::nlev), [&] (const int k) {
    const auto qv_ik = dry_atm.qv(i,k);
    for (int m = 0; m < mam_coupling::num_aero_modes(); ++m) {
      wet_aero.int_aero_nmr[m](i,k) = PF::calculate_wetmmr_from_drymmr(dry_aero.int_aero_nmr[m](i,k), qv_ik);
      if (wet_aero.cld_aero_nmr[m].data()) {
        wet_aero.cld_aero_nmr[m](i,k) = PF::calculate_wetmmr_from_drymmr(dry_aero.cld_aero_nmr[m](i,k), qv_ik);
      }
      for (int a = 0; a < mam_coupling::num_aero_species(); ++a) {
        if (wet_aero.int_aero_mmr[m][a].data()) {
          wet_aero.int_aero_mmr[m][a](i,k) = PF::calculate_wetmmr_from_drymmr(dry_aero.int_aero_mmr[m][a](i,k), qv_ik);
        }
        if (wet_aero.cld_aero_mmr[m][a].data()) {
          wet_aero.cld_aero_mmr[m][a](i,k) = PF::calculate_wetmmr_from_drymmr(dry_aero.cld_aero_mmr[m][a](i,k), qv_ik);
        }
      }
    }
    for (int g = 0; g < mam_coupling::num_aero_gases(); ++g) {
      wet_aero.gas_mmr[g](i,k) = PF::calculate_wetmmr_from_drymmr(dry_aero.gas_mmr[g](i,k), qv_ik);
    }
  });
}

} // namespace scream::mam_coupling

#endif
