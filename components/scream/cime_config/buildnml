#!/usr/bin/env python3

"""
Namelist creator for E3SM's SCREAM component

This script is mostly for processing the scream_input.yaml file.

See SCREAM_YAML_README for documentation on how to use scream_input.yaml.
"""

import os, sys, re
from collections import OrderedDict

import xml.etree.ElementTree as ET

_CIMEROOT = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..","..","..","cime")
sys.path.append(os.path.join(_CIMEROOT, "scripts", "Tools"))

# Add path to scream libs
sys.path.append(os.path.join(os.path.dirname(os.path.dirname(__file__)), "scripts"))

# Cime imports
from standard_script_setup import *
from CIME.case import Case
from CIME.utils import expect, safe_copy, SharedArea
from CIME.buildnml import parse_input

# SCREAM imports
from utils import ensure_yaml
ensure_yaml()
import yaml

logger = logging.getLogger(__name__)

CIME_VAR_RE = re.compile(r'[$][{](\w+)[}]')

###############################################################################
def do_cime_vars(entry, case):
###############################################################################
    """
    For a parameter value, process any references to case values ("${CASEVAR}")
    """
    m = CIME_VAR_RE.search(entry)
    while m:
        cime_var = m.groups()[0]
        value = case.get_value(cime_var)
        expect(value is not None, "Cannot resolve yaml entry {}, CIME has no value for {}".format(entry, cime_var))
        entry = entry.replace("${{{}}}".format(cime_var), value)
        m = CIME_VAR_RE.search(entry)

    return entry

###############################################################################
def ordered_dump(data, item, Dumper=yaml.SafeDumper, **kwds):
###############################################################################
    """
    Copied from: https://stackoverflow.com/a/21912744
    Added ability to pass filename
    """
    class OrderedDumper(Dumper):
        pass
    def _dict_representer(dumper, data):
        return dumper.represent_mapping(
            yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,
            data.items())
    OrderedDumper.add_representer(OrderedDict, _dict_representer)

    if isinstance(item, str) and item.endswith(".yaml"):
        # Item is a filepath
        with open(item, "w") as fd:
            return yaml.dump(data, fd, OrderedDumper, **kwds)
    else:
        return yaml.dump(data, item, OrderedDumper, **kwds)

###############################################################################
def evaluate_selectors(element, case, ez_selectors):
###############################################################################
    """
    Evaluate and remove selectors from the unprocessed XML nml file in the repo.

    Elements with selectors are removed. If the selector evaulates to True, then
    the corresponding element text becomes the new text value of the original
    (no-selectors, AKA default) element.
    """
    child_values = {} # elem_name -> evaluated XML element
    children_to_remove = []
    for child in element:
        child_name = child.tag
        child_val = child.text

        # Note: in our system, an XML element is either a "node" (has children)
        # or a "leaf" (has a value).
        has_children = len(child) > 0
        if not has_children:
            selectors = child.attrib
            if selectors:
                # This is a key assumption. The default value element must exist
                # and come first, before selector elements
                expect(child_name in child_values, "Child {} with selectors has no default value".format(child_name))
                all_match = True
                for k, v in selectors.items():
                    val_re = re.compile(v)

                    if k in ez_selectors:
                        ez_env, ez_regex = ez_selectors[k]
                        case_val = case.get_value(ez_env)
                        expect(case_val is not None, "Could not get selector value {} from case".format(ez_env))

                        ez_regex_re = re.compile(ez_regex)
                        m = ez_regex_re.match(case_val)
                        if m:
                            val = m.groups()[0]
                        else:
                            # If the regex doesn't even match the case val, then we consider
                            # the selector to evaluate to False. Setting the raw val to the
                            # string below should ensure the selector will never match.
                            val = "DOES NOT MATCH"

                    else:
                        val = case.get_value(k)
                        expect(val is not None, "Could not get selector value {} from case".format(k))


                    if val_re.match(val) is None:
                        all_match = False
                        break

                if all_match:
                    orig_child = child_values[child_name]
                    orig_child.text = do_cime_vars(child_val, case)

                children_to_remove.append(child)

            else:
                expect(child_name not in child_values, "Repeat of child {} without selectors".format(child_name))
                child_values[child_name] = child
                child.text = do_cime_vars(child_val, case)

        else:
            evaluate_selectors(child, case, ez_selectors)

    for child_to_remove in children_to_remove:
        element.remove(child_to_remove)

###############################################################################
def create_raw_xml_file(case, caseroot):
###############################################################################
    """
    Create the raw $case/namelist_scream.xml file. This file is intended to be
    modified by users via editor or the atm-config-chg script if they want
    to make tweaks to input files (yaml and/or nml).
    """
    src = os.path.join(case.get_value("SRCROOT"), "components/scream/cime_config/namelist_defaults_scream.xml")

    raw_xml_file = os.path.join(caseroot, "namelist_scream.xml")
    if os.path.exists(raw_xml_file):
        print("{} already exists, will not overwrite. Remove to regenerate".format(raw_xml_file))
    else:
        with open(src, "r") as fd:
            tree = ET.parse(fd)
            root = tree.getroot()

        selectors = None
        selectors_elem = None
        for child in root:
            if selectors is None:
                expect(child.tag == "selectors", "Unexpected child.tag {}".format(child.tag))
                selectors_elem = child

                selectors = {}
                for selector in child:
                    expect(selector.tag == "selector", "Expected selector tag, not {}".format(selector.tag))

                    selector_name  = selector.attrib["name"]
                    selector_env   = selector.attrib["case_env"]
                    if "regex" in selector.attrib:
                        selector_regex = selector.attrib["regex"]
                    else:
                        selector_regex = ".*" # Just grab the whole thing

                    selectors[selector_name] = (selector_env, selector_regex)

            else:
                expect(child.tag == "file", "Unexpected child.tag {}".format(child.tag))
                expect("name" in child.attrib, "file element missing required 'name' attribute")
                expect("format" in child.attrib, "file element missing required 'format' attribute")

                for grandchild in child:
                    evaluate_selectors(grandchild, case, selectors)

        if selectors_elem is not None:
            root.remove(selectors_elem)

        tree.write(raw_xml_file)

###############################################################################
def refine_type(entry):
###############################################################################
    """
    Try to convert the text entry to the appropriate type based on its contents.
    """
    if "," in entry:
        return [refine_type(item) for item in entry.split(", ") if item.strip() != ""]

    if entry.upper() == "TRUE":
        return True
    elif entry.upper() == "FALSE":
        return False

    try:
        v = int(entry)
        return v
    except ValueError:
        pass

    try:
        v = float(entry)
        return v
    except ValueError:
        return entry

###############################################################################
def convert_to_dict(element):
###############################################################################
    """
    Convert an XML element to a dictonary where the tags are the keys
    """
    result = OrderedDict()
    for child in element:
        child_name = child.tag.replace("__", " ")
        child_val = child.text

        has_children = len(child) > 0
        if not has_children:
            result[child_name] = refine_type(child_val)
        else:
            result[child_name] = convert_to_dict(child)

    return result

###############################################################################
def dump_to_nml(dict_contents, fd):
###############################################################################
    """
    Convert a dictionary to namelist file
    """
    for k, v in dict_contents.items():
        if isinstance(v, dict):
            fd.write("&{}\n".format(k))
            dump_to_nml(v, fd)
            fd.write("/\n")

        elif isinstance(v, list):
            fd.write("{}(:) = {}\n".format(k, ", ".join(v)))
        elif isinstance(v, str):
            fd.write("{} = '{}'\n".format(k, v))
        else:
            fd.write("{} = {}\n".format(k, v))

###############################################################################
def create_nml_files(caseroot, rundir):
###############################################################################
    """
    Based on $case/namelist_scream.xml, create the actual input files.
    """
    raw_xml_file = os.path.join(caseroot, "namelist_scream.xml")
    with open(raw_xml_file, "r") as fd:
        tree = ET.parse(fd)
        root = tree.getroot()

    result = {}
    for child in root:
        expect(child.tag == "file", "Unexpected child.tag {}".format(child.tag))
        expect("name" in child.attrib, "file element missing required 'name' attribute")
        expect("format" in child.attrib, "file element missing required 'format' attribute")

        nml_filename    = os.path.join(rundir, child.attrib["name"])
        nml_file_format = child.attrib["format"]

        dict_contents = convert_to_dict(child)

        if nml_file_format == "yaml":
            with open(nml_filename, "w") as fd:
                fd.write(
"""################################################################
# Do NOT modify this file. It is generated by scream/buildnml using
# the data from $case/namelist_scream.xml. If you want to make some
# local changes, you can edit this XML file or use atm-config-chg.
################################################################
""")
                ordered_dump(dict_contents, fd)

        elif nml_file_format == "nml":
            with open(nml_filename, "w") as fd:
                fd.write(
"""!---------------------------------------------------------------
! Do NOT modify this file. It is generated by scream/buildnml using
! the data from $case/namelist_scream.xml. If you want to make some
! local changes, you can edit this XML file or use atm-config-chg.
!---------------------------------------------------------------
""")
                dump_to_nml(dict_contents, fd)

        else:
            expect(False, "Unknown nml file format '{}'".format(nml_file_format))

        result[child.attrib["name"]] = dict_contents

    return result

###############################################################################
def buildnml(case, caseroot, compname):
###############################################################################
    expect(compname == "scream", compname)

    rundir   = case.get_value("RUNDIR")
    target   = os.path.join(rundir, "data")
    src      = os.path.join(case.get_value("SRCROOT"), "components/scream/data")

    #
    # Copy scream/data to rundir/data
    #
    with SharedArea():
        if not os.path.isdir(target):
            os.mkdir(target)

        for item in os.listdir(src):
            # Do not overwrite existing files because that would remove any
            # local mods made by the user.
            if not os.path.exists(os.path.join(target, item)):
                safe_copy(os.path.join(src, item), target)

        # Copy nml config change/query scripts
        safe_copy(os.path.join(src, "../scripts/atm-config-chg"), caseroot)

    #
    # Create the raw/processed XML input file and create nml files
    # from it.
    #
    create_raw_xml_file(case, caseroot)

    nmls_as_dicts = create_nml_files(caseroot, rundir)
    scream_input = nmls_as_dicts["data/scream_input.yaml"]

    #
    # Create input data list
    #
    input_data_list_file = "{}/Buildconf/scream.input_data_list".format(caseroot)
    if os.path.exists(input_data_list_file):
        os.remove(input_data_list_file)

    input_file = scream_input["Atmosphere Driver"]["Initial Conditions"]["Physics GLL"]["Filename"]
    tables     = scream_input["SCREAM"]["Input Files"]
    with open(input_data_list_file, "w") as fd:
        fd.write("ic_file = {}\n".format(input_file))
        for idx, table in enumerate(tables):
            fd.write("table_{} = {}\n".format(idx, table))

    # SCREAM is currently hardcoded to expect tables to be in data
    for table in tables:
        table_name = os.path.basename(table)
        tgt_table = os.path.join(target, table_name)
        if not os.path.exists(tgt_table) and not os.path.islink(tgt_table):
            os.symlink(table, os.path.join(target, table_name))

###############################################################################
def _main_func():
###############################################################################
    caseroot = parse_input(sys.argv)
    with Case(caseroot) as case:
        buildnml(case, caseroot, "scream")

if __name__ == "__main__":
    _main_func()
