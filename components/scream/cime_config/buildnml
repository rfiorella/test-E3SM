#!/usr/bin/env python3

"""
Namelist creator for E3SM's SCREAM component

This scripts takes the namelist_defaults_scream.xml file from the repo
and produces the processed $case/namelist_scream.xml. From the processed
file, raw input files are produced which should not be modified by users.

This script can be internally tested standalone via: buildnml --test

It is also encouraged to run pylint on this file when it gets changed:
python3 -m pylint --disable C --disable R buildnml
Some import errors are expected and can be ignored
"""

import os, sys, re
from collections import OrderedDict

import xml.etree.ElementTree as ET

_CIMEROOT = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..","..","..","cime")
sys.path.append(os.path.join(_CIMEROOT, "scripts", "Tools"))

# Add path to scream libs
sys.path.append(os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "scripts"))

# Cime imports
from standard_script_setup import *
from CIME.case import Case
from CIME.utils import expect, safe_copy, SharedArea
from CIME.buildnml import parse_input

# SCREAM imports
from utils import ensure_yaml
ensure_yaml()
import yaml

logger = logging.getLogger(__name__)

CIME_VAR_RE = re.compile(r'[$][{](\w+)[}]')

###############################################################################
class MockCase(object):
###############################################################################

    def __init__(self, kv_dict):
        self._kv_dict = dict(kv_dict)

    def get_value(self, key):
        if key in self._kv_dict:
            return self._kv_dict[key]
        else:
            return None

###############################################################################
def do_cime_vars(entry, case):
###############################################################################
    """
    For a parameter value, process any references to case values ("${CASEVAR}")

    >>> case = MockCase({'foo':1, 'bar':2, 'baz_bar':'blah', 'baz2_bar2':4})
    >>> do_cime_vars('${foo}', case)
    '1'
    >>> do_cime_vars('hi ${foo} there', case)
    'hi 1 there'
    >>> do_cime_vars('hi ${foo}${bar} there', case)
    'hi 12 there'
    >>> do_cime_vars('hi ${baz_bar} there', case)
    'hi blah there'
    >>> do_cime_vars('hi ${baz2_bar2} there', case)
    'hi 4 there'
    >>> do_cime_vars('hi ${invalid} there', case)
    Traceback (most recent call last):
      ...
    CIME.utils.CIMEError: ERROR: Cannot resolve yaml entry 'hi ${invalid} there', CIME has no value for 'invalid'
    """
    m = CIME_VAR_RE.search(entry)
    while m:
        cime_var = m.groups()[0]
        value = case.get_value(cime_var)
        expect(value is not None, "Cannot resolve yaml entry '{}', CIME has no value for '{}'".format(entry, cime_var))
        entry = entry.replace("${{{}}}".format(cime_var), str(value))
        m = CIME_VAR_RE.search(entry)

    return entry

###############################################################################
def ordered_dump(data, item, Dumper=yaml.SafeDumper, **kwds):
###############################################################################
    """
    Copied from: https://stackoverflow.com/a/21912744
    Added ability to pass filename
    """
    class OrderedDumper(Dumper):
        pass
    def _dict_representer(dumper, data):
        return dumper.represent_mapping(
            yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,
            data.items())
    OrderedDumper.add_representer(OrderedDict, _dict_representer)

    if isinstance(item, str) and item.endswith(".yaml"):
        # Item is a filepath
        with open(item, "w") as fd:
            return yaml.dump(data, fd, OrderedDumper, **kwds)
    else:
        return yaml.dump(data, item, OrderedDumper, **kwds)

###############################################################################
def evaluate_selectors(element, case, ez_selectors):
###############################################################################
    """
    Evaluate and remove selectors from the unprocessed XML nml file in the repo.

    Elements with selectors are removed. If the selector evaulates to True, then
    the corresponding element text becomes the new text value of the original
    (no-selectors, AKA default) element.
    """
    child_values = {} # elem_name -> evaluated XML element
    children_to_remove = []
    for child in element:
        child_name = child.tag
        child_val = child.text

        # Note: in our system, an XML element is either a "node" (has children)
        # or a "leaf" (has a value).
        has_children = len(child) > 0
        if not has_children:
            selectors = child.attrib
            if selectors:
                # This is a key assumption. The default value element must exist
                # and come first, before selector elements
                expect(child_name in child_values,
                       "Child '{}' with selectors has either no default value or default value does not come before selector element".format(child_name))
                all_match = True
                for k, v in selectors.items():
                    val_re = re.compile(v)

                    if k in ez_selectors:
                        ez_env, ez_regex = ez_selectors[k]
                        case_val = case.get_value(ez_env)
                        expect(case_val is not None, "Bad easy selector '{}' definition. Relies on unknown case value '{}'".format(k, ez_env))

                        ez_regex_re = re.compile(ez_regex)
                        m = ez_regex_re.match(case_val)
                        if m:
                            groups = m.groups()
                            expect(len(groups) == 1, "Selector '{}' has invalid custom regex '{}' which does not capture exactly 1 group".format(k, ez_regex))
                            val = groups[0]
                        else:
                            # If the regex doesn't even match the case val, then we consider
                            # string below should ensure the selector will never match.
                            val = None

                    else:
                        val = case.get_value(k)
                        expect(val is not None, "Bad selector '{0}' for child '{1}'. '{0}' is not a valid case value or easy selector".format(k, child_name))


                    if val is None or val_re.match(val) is None:
                        all_match = False
                        break

                if all_match:
                    orig_child = child_values[child_name]
                    orig_child.text = do_cime_vars(child_val, case)

                children_to_remove.append(child)

            else:
                expect(child_name not in child_values, "Repeat of child '{}' without selectors".format(child_name))
                child_values[child_name] = child
                child.text = do_cime_vars(child_val, case)

        else:
            evaluate_selectors(child, case, ez_selectors)

    for child_to_remove in children_to_remove:
        element.remove(child_to_remove)

###############################################################################
def _create_raw_xml_file_impl(case, defaults_xml):
###############################################################################
    """
    >>> case = MockCase({'ATM_GRID':'ne4ne4', 'SCREAM_CMAKE_OPTIONS':'FOO=ON SCREAM_NUM_VERTICAL_LEV 128 BAR=OFF'})
    >>> test_empty_selectors = '''
    ... <namelist_defaults>
    ...   <selectors>
    ...   </selectors>
    ...   <file name="test.yaml" format="yaml">
    ...     <testval>42</testval>
    ...   </file>
    ... </namelist_defaults>
    ... '''
    >>> print(_create_raw_xml_file_impl(case, test_empty_selectors))
    <namelist_defaults>
      <file name="test.yaml" format="yaml">
        <testval>42</testval>
      </file>
    </namelist_defaults>
    >>> ######################################################################
    >>> test_err_repeat_val = '''
    ... <namelist_defaults>
    ...   <selectors>
    ...   </selectors>
    ...   <file name="test.yaml" format="yaml">
    ...     <testval>42</testval>
    ...     <testval>420</testval>
    ...   </file>
    ... </namelist_defaults>
    ... '''
    >>> _create_raw_xml_file_impl(case, test_err_repeat_val)
    Traceback (most recent call last):
      ...
    CIME.utils.CIMEError: ERROR: Repeat of child 'testval' without selectors
    >>> ######################################################################
    >>> test_err_bad_selector = '''
    ... <namelist_defaults>
    ...   <selectors>
    ...   </selectors>
    ...   <file name="test.yaml" format="yaml">
    ...     <testval>42</testval>
    ...     <testval foo="bar">420</testval>
    ...   </file>
    ... </namelist_defaults>
    ... '''
    >>> _create_raw_xml_file_impl(case, test_err_bad_selector)
    Traceback (most recent call last):
      ...
    CIME.utils.CIMEError: ERROR: Bad selector 'foo' for child 'testval'. 'foo' is not a valid case value or easy selector
    >>> ######################################################################
    >>> test_err_missing_default = '''
    ... <namelist_defaults>
    ...   <selectors>
    ...     <selector name="hgrid" case_env="ATM_GRID"/>
    ...   </selectors>
    ...   <file name="test.yaml" format="yaml">
    ...     <testval hgrid="ne4ne4">420</testval>
    ...   </file>
    ... </namelist_defaults>
    ... '''
    >>> _create_raw_xml_file_impl(case, test_err_missing_default)
    Traceback (most recent call last):
      ...
    CIME.utils.CIMEError: ERROR: Child 'testval' with selectors has either no default value or default value does not come before selector element
    >>> ######################################################################
    >>> test_err_wrong_order = '''
    ... <namelist_defaults>
    ...   <selectors>
    ...     <selector name="hgrid" case_env="ATM_GRID"/>
    ...   </selectors>
    ...   <file name="test.yaml" format="yaml">
    ...     <testval hgrid="ne4ne4">420</testval>
    ...     <testval>42</testval>
    ...   </file>
    ... </namelist_defaults>
    ... '''
    >>> _create_raw_xml_file_impl(case, test_err_wrong_order)
    Traceback (most recent call last):
      ...
    CIME.utils.CIMEError: ERROR: Child 'testval' with selectors has either no default value or default value does not come before selector element
    >>> ######################################################################
    >>> test_err_bad_selector_def = '''
    ... <namelist_defaults>
    ...   <selectors>
    ...     <selector name="hgrid" case_env="BADVAL"/>
    ...   </selectors>
    ...   <file name="test.yaml" format="yaml">
    ...     <testval>42</testval>
    ...     <testval hgrid="ne4ne4">420</testval>
    ...   </file>
    ... </namelist_defaults>
    ... '''
    >>> _create_raw_xml_file_impl(case, test_err_bad_selector_def)
    Traceback (most recent call last):
      ...
    CIME.utils.CIMEError: ERROR: Bad easy selector 'hgrid' definition. Relies on unknown case value 'BADVAL'
    >>> ######################################################################
    >>> test_err_bad_selector_def_regex = '''
    ... <namelist_defaults>
    ...   <selectors>
    ...     <selector name="hgrid" case_env="ATM_GRID" regex=".*"/>
    ...   </selectors>
    ...   <file name="test.yaml" format="yaml">
    ...     <testval>42</testval>
    ...     <testval hgrid="ne4ne4">420</testval>
    ...   </file>
    ... </namelist_defaults>
    ... '''
    >>> _create_raw_xml_file_impl(case, test_err_bad_selector_def_regex)
    Traceback (most recent call last):
      ...
    CIME.utils.CIMEError: ERROR: Selector 'hgrid' has invalid custom regex '.*' which does not capture exactly 1 group
    >>> ######################################################################
    >>> full_test = '''
    ... <namelist_defaults>
    ...   <selectors>
    ...     <selector name="hgrid" case_env="ATM_GRID"/>
    ...     <selector name="nlev" case_env="SCREAM_CMAKE_OPTIONS" regex=".*SCREAM_NUM_VERTICAL_LEV ([0-9]+).*"/>
    ...     <selector name="nomatch" case_env="SCREAM_CMAKE_OPTIONS" regex=".*(NO_MATCH).*"/>
    ...   </selectors>
    ...   <file name="test.yaml" format="yaml">
    ...     <group1>
    ...       <testval>42</testval>
    ...       <testval2>123</testval2>
    ...       <interleave>hi</interleave>
    ...       <testval2 hgrid="ne4ne4">1234</testval2>
    ...     </group1>
    ...     <group2>
    ...       <testval>42</testval>
    ...       <testval2>123</testval2>
    ...       <interleave>hi</interleave>
    ...       <testval2 hgrid="ne4ne4">1234</testval2>
    ...       <prec_tester>1</prec_tester>
    ...       <prec_tester hgrid="ne4ne4" nlev="128">2</prec_tester>
    ...       <prec_tester nlev="128">3</prec_tester>
    ...       <foo>1</foo>
    ...       <foo hgrid=".*ne4.*">2</foo>
    ...       <bar>1</bar>
    ...       <bar hgrid="no_match">2</bar>
    ...       <baz>1</baz>
    ...       <baz hgrid="no_match" nlev="128">2</baz>
    ...       <bat>1</bat>
    ...       <bat nlev="128" hgrid="no_match">2</bat>
    ...       <sel_regex_no_match>1</sel_regex_no_match>
    ...       <sel_regex_no_match nomatch=".*">2</sel_regex_no_match>
    ...     </group2>
    ...   </file>
    ... </namelist_defaults>
    ... '''
    >>> print(_create_raw_xml_file_impl(case, full_test))
    <namelist_defaults>
      <file name="test.yaml" format="yaml">
        <group1>
          <testval>42</testval>
          <testval2>1234</testval2>
          <interleave>hi</interleave>
          </group1>
        <group2>
          <testval>42</testval>
          <testval2>1234</testval2>
          <interleave>hi</interleave>
          <prec_tester>3</prec_tester>
          <foo>2</foo>
          <bar>1</bar>
          <baz>1</baz>
          <bat>1</bat>
          <sel_regex_no_match>1</sel_regex_no_match>
          </group2>
      </file>
    </namelist_defaults>
    """
    root = ET.fromstring(defaults_xml)

    selectors = None
    selectors_elem = None
    for child in root:
        if selectors is None:
            expect(child.tag == "selectors", "Unexpected child.tag {}".format(child.tag))
            selectors_elem = child

            selectors = {}
            for selector in child:
                expect(selector.tag == "selector", "Expected selector tag, not {}".format(selector.tag))

                selector_name  = selector.attrib["name"]
                selector_env   = selector.attrib["case_env"]
                if "regex" in selector.attrib:
                    selector_regex = selector.attrib["regex"]
                else:
                    selector_regex = "(.*)" # Just grab the whole thing

                selectors[selector_name] = (selector_env, selector_regex)

        else:
            expect(child.tag == "file", "Unexpected child.tag {}".format(child.tag))
            expect("name" in child.attrib, "file element missing required 'name' attribute")
            expect("format" in child.attrib, "file element missing required 'format' attribute")

            evaluate_selectors(child, case, selectors)

    if selectors_elem is not None:
        root.remove(selectors_elem)

    return ET.tostring(root, encoding="unicode")

###############################################################################
def create_raw_xml_file(case, caseroot):
###############################################################################
    """
    Create the raw $case/namelist_scream.xml file. This file is intended to be
    modified by users via editor or the atm-config-chg script if they want
    to make tweaks to input files (yaml and/or nml).
    """
    src = os.path.join(case.get_value("SRCROOT"), "components/scream/cime_config/namelist_defaults_scream.xml")

    raw_xml_file = os.path.join(caseroot, "namelist_scream.xml")
    if os.path.exists(raw_xml_file):
        print("{} already exists, will not overwrite. Remove to regenerate".format(raw_xml_file))
    else:
        with open(src, "r") as fd:
            raw_xml = _create_raw_xml_file_impl(case, fd.read())

        with open(raw_xml_file, "w") as fd:
            fd.write(raw_xml)

###############################################################################
def refine_type(entry):
###############################################################################
    """
    Try to convert the text entry to the appropriate type based on its contents.
    """
    if "," in entry:
        return [refine_type(item) for item in entry.split(", ") if item.strip() != ""]

    if entry.upper() == "TRUE":
        return True
    elif entry.upper() == "FALSE":
        return False

    try:
        v = int(entry)
        return v
    except ValueError:
        pass

    try:
        v = float(entry)
        return v
    except ValueError:
        return entry

###############################################################################
def convert_to_dict(element):
###############################################################################
    """
    Convert an XML element to a dictonary where the tags are the keys
    """
    result = OrderedDict()
    for child in element:
        child_name = child.tag.replace("__", " ")
        child_val = child.text

        has_children = len(child) > 0
        if not has_children:
            result[child_name] = refine_type(child_val)
        else:
            result[child_name] = convert_to_dict(child)

    return result

###############################################################################
def _dump_to_nml_impl(dict_contents):
###############################################################################
    """
    >>> xml = '''
    ... <file name="test.yaml" format="yaml">
    ...   <group1>
    ...     <testval>42</testval>
    ...     <testval2>42.3</testval2>
    ...     <interleave>hi</interleave>
    ...    </group1>
    ...    <group2>
    ...      <testval>False</testval>
    ...      <testval2>1, 2, 3, 4.2</testval2>
    ...      <interleave>hi, there</interleave>
    ...    </group2>
    ...  </file>
    ... '''
    >>> root = ET.fromstring(xml)
    >>> print(_dump_to_nml_impl(convert_to_dict(root)))
    &group1
    testval = 42
    testval2 = 42.3
    interleave = 'hi'
    /
    &group2
    testval = .false.
    testval2(:) = 1, 2, 3, 4.2
    interleave(:) = hi, there
    /
    <BLANKLINE>
    """
    result = ""
    for k, v in dict_contents.items():
        if isinstance(v, dict):
            result += "&{}\n".format(k)
            result += _dump_to_nml_impl(v)
            result += "/\n"

        elif isinstance(v, list):
            result += "{}(:) = {}\n".format(k, ", ".join([str(item) for item in v]))
        elif isinstance(v, bool):
            result += "{} = {}\n".format(k, ".true." if v else ".false.")
        elif isinstance(v, str):
            result += "{} = '{}'\n".format(k, v)
        else:
            result += "{} = {}\n".format(k, v)

    return result

###############################################################################
def dump_to_nml(dict_contents, fd):
###############################################################################
    """
    Convert a dictionary to namelist file
    """
    fd.write(
"""!---------------------------------------------------------------
! Do NOT modify this file. It is generated by scream/buildnml using
! the data from $case/namelist_scream.xml. If you want to make some
! local changes, you can edit this XML file or use atm-config-chg.
!---------------------------------------------------------------
""")

    fd.write(_dump_to_nml_impl(dict_contents))

###############################################################################
def create_nml_files(caseroot, rundir):
###############################################################################
    """
    Based on $case/namelist_scream.xml, create the actual input files.
    """
    raw_xml_file = os.path.join(caseroot, "namelist_scream.xml")
    with open(raw_xml_file, "r") as fd:
        tree = ET.parse(fd)
        root = tree.getroot()

    result = {}
    for child in root:
        expect(child.tag == "file", "Unexpected child.tag {}".format(child.tag))
        expect("name" in child.attrib, "file element missing required 'name' attribute")
        expect("format" in child.attrib, "file element missing required 'format' attribute")

        nml_filename    = os.path.join(rundir, child.attrib["name"])
        nml_file_format = child.attrib["format"]

        dict_contents = convert_to_dict(child)

        if nml_file_format == "yaml":
            with open(nml_filename, "w") as fd:
                fd.write(
"""################################################################
# Do NOT modify this file. It is generated by scream/buildnml using
# the data from $case/namelist_scream.xml. If you want to make some
# local changes, you can edit this XML file or use atm-config-chg.
################################################################
""")
                ordered_dump(dict_contents, fd)

        elif nml_file_format == "nml":
            with open(nml_filename, "w") as fd:
                dump_to_nml(dict_contents, fd)

        else:
            expect(False, "Unknown nml file format '{}'".format(nml_file_format))

        result[child.attrib["name"]] = dict_contents

    return result

###############################################################################
def buildnml(case, caseroot, compname):
###############################################################################
    expect(compname == "scream", compname)

    rundir   = case.get_value("RUNDIR")
    target   = os.path.join(rundir, "data")
    src      = os.path.join(case.get_value("SRCROOT"), "components/scream/data")

    #
    # Copy scream/data to rundir/data
    #
    with SharedArea():
        if not os.path.isdir(target):
            os.mkdir(target)

        for item in os.listdir(src):
            # Do not overwrite existing files because that would remove any
            # local mods made by the user.
            if not os.path.exists(os.path.join(target, item)):
                safe_copy(os.path.join(src, item), target)

        # Copy nml config change/query scripts
        safe_copy(os.path.join(src, "../scripts/atm-config-chg"), caseroot)

    #
    # Create the raw/processed XML input file and create nml files
    # from it.
    #
    create_raw_xml_file(case, caseroot)

    nmls_as_dicts = create_nml_files(caseroot, rundir)
    scream_input = nmls_as_dicts["data/scream_input.yaml"]

    #
    # Create input data list
    #
    input_data_list_file = "{}/Buildconf/scream.input_data_list".format(caseroot)
    if os.path.exists(input_data_list_file):
        os.remove(input_data_list_file)

    input_file = scream_input["Atmosphere Driver"]["Initial Conditions"]["Physics GLL"]["Filename"]
    tables     = scream_input["SCREAM"]["Input Files"]
    with open(input_data_list_file, "w") as fd:
        fd.write("ic_file = {}\n".format(input_file))
        for idx, table in enumerate(tables):
            fd.write("table_{} = {}\n".format(idx, table))

    # SCREAM is currently hardcoded to expect tables to be in data
    for table in tables:
        table_name = os.path.basename(table)
        tgt_table = os.path.join(target, table_name)
        if not os.path.exists(tgt_table) and not os.path.islink(tgt_table):
            os.symlink(table, os.path.join(target, table_name))

###############################################################################
def _main_func():
###############################################################################
    if "--test" in sys.argv:
        from doctest import testmod
        testmod()

    else:
        caseroot = parse_input(sys.argv)
        with Case(caseroot) as case:
            buildnml(case, caseroot, "scream")

if __name__ == "__main__":
    _main_func()
