#!/usr/bin/env python3

"""
Namelist creator for E3SM's SCREAM component

This script is mostly for processing the scream_input.yaml file.

See SCREAM_YAML_README for documentation on how to use scream_input.yaml.
"""

import os, sys, re
from collections import OrderedDict

_CIMEROOT = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..","..","..","cime")
sys.path.append(os.path.join(_CIMEROOT, "scripts", "Tools"))

# Add path to scream libs
sys.path.append(os.path.join(os.path.dirname(os.path.dirname(__file__)), "scripts"))

# Cime imports
from standard_script_setup import *
from CIME.case import Case
from CIME.utils import expect, safe_copy, SharedArea
from CIME.buildnml import parse_input

# SCREAM imports
from utils import ensure_yaml
ensure_yaml()
import yaml

logger = logging.getLogger(__name__)

CIME_VAR_RE = re.compile(r'[$][{](\w+)[}]')
SWITCH_RE   = re.compile(r'<\s*(\w+)\s*:')

###############################################################################
def do_cime_vars(entry, case):
###############################################################################
    m = CIME_VAR_RE.search(entry)
    while m:
        cime_var = m.groups()[0]
        value = case.get_value(cime_var)
        expect(value is not None, "Cannot resolve yaml entry {}, CIME has no value for {}".format(entry, cime_var))
        entry = entry.replace("${{{}}}".format(cime_var), value)
        m = CIME_VAR_RE.search(entry)

    return entry

###############################################################################
def do_switches(entry):
###############################################################################
    m = SWITCH_RE.search(entry)
    while m:
        begin_switch_idx, end_cond_idx = m.span()
        value = m.groups()[0]
        opens = 1
        idx = end_cond_idx
        segments = [""]
        for idx in range(end_cond_idx, len(entry)):
            if entry[idx] == "<":
                opens += 1
            elif entry[idx] == ">" and entry[idx-1] != "=":
                opens -= 1
                if opens == 0:
                    break

            if entry[idx] == ":" and opens == 1:
                segments.append("")
            else:
                segments[-1] += entry[idx]

        expect(idx < len(entry), "Switch statement parse error in string '{}'".format(entry))
        end_switch_idx = idx + 1
        best_val = None
        for segment in segments:
            components = segment.split("=>", 1)
            if (len(components) == 1 or '<' in components[0]):
                if best_val is None:
                    best_val = do_switches(segment).strip()
            else:
                compare = re.compile(components[0].strip())
                if compare.match(value):
                    best_val = do_switches(components[-1]).strip()
                    break

        expect(best_val is not None, "Couldn't resolve switch statement for '{}', no matches".format(entry))

        entry = entry[0:begin_switch_idx] + best_val + entry[end_switch_idx:]
        m = SWITCH_RE.search(entry)

    return entry

###############################################################################
def refine_type(entry):
###############################################################################
    try:
        v = int(entry)
        return v
    except ValueError:
        pass

    try:
        v = float(entry)
        return v
    except ValueError:
        return entry

###############################################################################
def process_leaf(leaf_str, case):
###############################################################################
    orig_str = leaf_str
    leaf_str = do_cime_vars(leaf_str, case)
    leaf_str = do_switches(leaf_str)
    if leaf_str != orig_str:
        return True, refine_type(leaf_str)
    else:
        return False, orig_str

###############################################################################
def process_node(node, itr, case):
###############################################################################
    """
    Processes a node in the YAML data. A node is a piece of data in the python
    dict representing the "raw" YAML. Because we support an extra level of
    special syntax, described in SCREAM_YAML_README, we must do an extra
    phase of processing this data. A node can be a dict, list, or string.
    String data is considered a terminating 'leaf'.
    """
    modified = False
    for k, v in itr:
        if isinstance(v, str):
            curr_modified, leaf_val = process_leaf(v, case)
            if curr_modified:
                node[k] = leaf_val
                modified = True

        elif isinstance(v, dict):
            modified |= process_node(v, v.items(), case)

        elif isinstance(v, list):
            modified |= process_node(v, enumerate(v), case)

    return modified

###############################################################################
def ordered_load(item, Loader=yaml.SafeLoader, object_pairs_hook=OrderedDict):
###############################################################################
    """
    Copied from: https://stackoverflow.com/a/21912744
    Added ability to pass filename
    """
    class OrderedLoader(Loader):
        pass
    def construct_mapping(loader, node):
        loader.flatten_mapping(node)
        return object_pairs_hook(loader.construct_pairs(node))
    OrderedLoader.add_constructor(
        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,
        construct_mapping)

    if isinstance(item, str) and item.endswith(".yaml"):
        # Item is a filepath
        return yaml.load(open(item, "r"), OrderedLoader)
    else:
        return yaml.load(item, OrderedLoader)

###############################################################################
def ordered_dump(data, item, Dumper=yaml.SafeDumper, **kwds):
###############################################################################
    """
    Copied from: https://stackoverflow.com/a/21912744
    Added ability to pass filename
    """
    class OrderedDumper(Dumper):
        pass
    def _dict_representer(dumper, data):
        return dumper.represent_mapping(
            yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,
            data.items())
    OrderedDumper.add_representer(OrderedDict, _dict_representer)

    if isinstance(item, str) and item.endswith(".yaml"):
        # Item is a filepath
        with open(item, "w") as fd:
            return yaml.dump(data, fd, OrderedDumper, **kwds)
    else:
        return yaml.dump(data, item, OrderedDumper, **kwds)

###############################################################################
def buildnml(case, caseroot, compname):
###############################################################################
    expect(compname == "scream", compname)

    # Copy data inputs to a place where they are convenient to find the run
    # area.
    rundir   = case.get_value("RUNDIR")
    target   = os.path.join(rundir, "data")
    src      = os.path.join(case.get_value("SRCROOT"), "components/scream/data")
    yaml_tgt = os.path.join(target, "scream_input.yaml")

    # Copy scream/data to rundir/data
    with SharedArea():
        if not os.path.isdir(target):
            os.mkdir(target)

        for item in os.listdir(src):
            # Do not overwrite existing files because that would remove any
            # local mods made by the user.
            if not os.path.exists(os.path.join(target, item)):
                 safe_copy(os.path.join(src, item), target)

    # Load scream inputs from yaml
    scream_input = ordered_load(yaml_tgt)

    modified = process_node(scream_input, scream_input.items(), case)

    # Check If we have to re-dump the YAML file due to CIME case updates
    if modified:
        ordered_dump(scream_input, yaml_tgt)

    # Create homme namelists from scream inputs
    homme_nl_path = os.path.join(rundir, scream_input["Atmosphere Driver"]["Grids Manager"]["Dynamics Driven"]["Dynamics Namelist File Name"])
    with open(homme_nl_path, "w") as fd:
        for outer, inner in scream_input["HOMME"].items():
            fd.write("&{}\n".format(outer))
            for k, v in inner.items():
                if type(v) is str:
                    fd.write("{} = '{}'\n".format(k, v))
                elif type(v) is bool:
                    fd.write("{} = {}\n".format(k, str(v).lower()))
                else:
                    fd.write("{} = {}\n".format(k, v))

            fd.write("/\n")

    # Create input data list
    input_data_list_file = "{}/Buildconf/scream.input_data_list".format(caseroot)
    if os.path.exists(input_data_list_file):
        os.remove(input_data_list_file)

    input_file = scream_input["Atmosphere Driver"]["Initial Conditions"]["Physics GLL"]["Filename"]
    tables     = scream_input["SCREAM"]["Input Files"]
    with open(input_data_list_file, "w") as fd:
        fd.write("ic_file = {}\n".format(input_file))
        for idx, table in enumerate(tables):
            fd.write("table_{} = {}\n".format(idx, table))

    # SCREAM is currently hardcoded to expect tables to be in data
    for table in tables:
        table_name = os.path.basename(table)
        tgt_table = os.path.join(target, table_name)
        if not os.path.exists(tgt_table) and not os.path.islink(tgt_table):
            os.symlink(table, os.path.join(target, table_name))

###############################################################################
def _main_func():
###############################################################################
    caseroot = parse_input(sys.argv)
    with Case(caseroot) as case:
        buildnml(case, caseroot, "scream")

if __name__ == "__main__":
    _main_func()
