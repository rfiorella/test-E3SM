#!/usr/bin/env python3

"""
Namelist creator for E3SM's SCREAM component

This script is mostly for processing the scream_input.yaml file.

See SCREAM_YAML_README for documentation on how to use scream_input.yaml.
"""

import os, sys, re
from collections import OrderedDict

import xml.etree.ElementTree as ET

_CIMEROOT = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..","..","..","cime")
sys.path.append(os.path.join(_CIMEROOT, "scripts", "Tools"))

# Add path to scream libs
sys.path.append(os.path.join(os.path.dirname(os.path.dirname(__file__)), "scripts"))

# Cime imports
from standard_script_setup import *
from CIME.case import Case
from CIME.utils import expect, safe_copy, SharedArea
from CIME.buildnml import parse_input

# SCREAM imports
from utils import ensure_yaml
ensure_yaml()
import yaml

logger = logging.getLogger(__name__)

CIME_VAR_RE = re.compile(r'[$][{](\w+)[}]')

###############################################################################
def do_cime_vars(entry, case):
###############################################################################
    m = CIME_VAR_RE.search(entry)
    while m:
        cime_var = m.groups()[0]
        value = case.get_value(cime_var)
        expect(value is not None, "Cannot resolve yaml entry {}, CIME has no value for {}".format(entry, cime_var))
        entry = entry.replace("${{{}}}".format(cime_var), value)
        m = CIME_VAR_RE.search(entry)

    return entry

###############################################################################
def ordered_dump(data, item, Dumper=yaml.SafeDumper, **kwds):
###############################################################################
    """
    Copied from: https://stackoverflow.com/a/21912744
    Added ability to pass filename
    """
    class OrderedDumper(Dumper):
        pass
    def _dict_representer(dumper, data):
        return dumper.represent_mapping(
            yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,
            data.items())
    OrderedDumper.add_representer(OrderedDict, _dict_representer)

    if isinstance(item, str) and item.endswith(".yaml"):
        # Item is a filepath
        with open(item, "w") as fd:
            return yaml.dump(data, fd, OrderedDumper, **kwds)
    else:
        return yaml.dump(data, item, OrderedDumper, **kwds)

###############################################################################
def evaluate_selectors(element, case):
###############################################################################
    child_values = {} # elem_name -> evaluated XML element
    children_to_remove = []
    for child in element:
        child_name = child.tag
        child_val = child.text

        has_children = False
        for grand_child in child:
            has_children = True
            break

        if not has_children:
            selectors = child.attrib
            if selectors:
                expect(child_name in child_values, "Child {} with selectors has no default value".format(child_name))
                all_match = True
                for k, v in selectors.items():
                    case_val = case.get_value(k)
                    val_re = re.compile(v)

                    if val_re.match(case_val) is None:
                        all_match = False
                        break

                if all_match:
                    orig_child = child_values[child_name]
                    orig_child.text = do_cime_vars(child_val, case)

                children_to_remove.append(child)

            else:
                expect(child_name not in child_values, "Repeat of child {} without selectors".format(child_name))
                child_values[child_name] = child
                child.text = do_cime_vars(child_val, case)

        else:
            evaluate_selectors(child, case)

    for child_to_remove in children_to_remove:
        element.remove(child_to_remove)

###############################################################################
def create_raw_xml_file(case, caseroot):
###############################################################################
    src = os.path.join(case.get_value("SRCROOT"), "components/scream/cime_config/namelist_defaults_scream.xml")

    raw_xml_file = os.path.join(caseroot, "namelist_scream.xml")
    if os.path.exists(raw_xml_file):
        print("{} already exists, will not overwrite. Remove to regenerate".format(raw_xml_file))
    else:
        with open(src, "r") as fd:
            tree = ET.parse(fd)
            root = tree.getroot()

        for child in root:
            expect(child.tag == "file", "Unexpected child.tag {}".format(child.tag))
            expect("name" in child.attrib, "file element missing required 'name' attribute")
            expect("format" in child.attrib, "file element missing required 'format' attribute")

            for grandchild in child:
                evaluate_selectors(grandchild, case)

        tree.write(raw_xml_file)

###############################################################################
def refine_type(entry):
###############################################################################
    if "," in entry:
        return [refine_type(item) for item in entry.split(", ") if item.strip() != ""]

    if entry.upper() == "TRUE":
        return True
    elif entry.upper() == "FALSE":
        return False

    try:
        v = int(entry)
        return v
    except ValueError:
        pass

    try:
        v = float(entry)
        return v
    except ValueError:
        return entry

###############################################################################
def convert_to_dict(element):
###############################################################################
    result = OrderedDict()
    for child in element:
        child_name = child.tag.replace("__", " ")
        child_val = child.text

        has_children = False
        for grand_child in child:
            has_children = True
            break

        if not has_children:
            result[child_name] = refine_type(child_val)

        else:
            result[child_name] = convert_to_dict(child)

    return result

###############################################################################
def dump_to_nml(dict_contents, fd):
###############################################################################
    for k, v in dict_contents.items():
        if isinstance(v, dict):
            fd.write("&{}\n".format(k))
            dump_to_nml(v, fd)
            fd.write("/\n")

        elif isinstance(v, list):
            fd.write("{}(:) = {}\n".format(k, ", ".join(v)))
        elif isinstance(v, str):
            fd.write("{} = '{}'\n".format(k, v))
        else:
            fd.write("{} = {}\n".format(k, v))

###############################################################################
def create_nml_files(case, caseroot, rundir):
###############################################################################
    raw_xml_file = os.path.join(caseroot, "namelist_scream.xml")
    with open(raw_xml_file, "r") as fd:
        tree = ET.parse(fd)
        root = tree.getroot()

    result = {}
    for child in root:
        expect(child.tag == "file", "Unexpected child.tag {}".format(child.tag))
        expect("name" in child.attrib, "file element missing required 'name' attribute")
        expect("format" in child.attrib, "file element missing required 'format' attribute")

        nml_filename    = os.path.join(rundir, child.attrib["name"])
        nml_file_format = child.attrib["format"]

        dict_contents = convert_to_dict(child)

        if nml_file_format == "yaml":
            with open(nml_filename, "w") as fd:
                fd.write(
"""################################################################
# Do NOT modify this file. It is generated by scream/buildnml using
# the data from $case/namelist_scream.xml. If you want to make some
# local changes, you can edit this XML file or use atm-config-chg.
################################################################
""")
                ordered_dump(dict_contents, fd)

        elif nml_file_format == "nml":
            with open(nml_filename, "w") as fd:
                fd.write(
"""!---------------------------------------------------------------
! Do NOT modify this file. It is generated by scream/buildnml using
! the data from $case/namelist_scream.xml. If you want to make some
! local changes, you can edit this XML file or use atm-config-chg.
!---------------------------------------------------------------
""")
                dump_to_nml(dict_contents, fd)

        else:
            expect(False, "Unknown nml file format '{}'".format(nml_file_format))

        result[child.attrib["name"]] = dict_contents

    return result

###############################################################################
def buildnml(case, caseroot, compname):
###############################################################################
    expect(compname == "scream", compname)

    # Copy data inputs to a place where they are convenient to find the run
    # area.
    rundir   = case.get_value("RUNDIR")
    target   = os.path.join(rundir, "data")
    src      = os.path.join(case.get_value("SRCROOT"), "components/scream/data")

    # Copy scream/data to rundir/data
    with SharedArea():
        if not os.path.isdir(target):
            os.mkdir(target)

        for item in os.listdir(src):
            # Do not overwrite existing files because that would remove any
            # local mods made by the user.
            if not os.path.exists(os.path.join(target, item)):
                 safe_copy(os.path.join(src, item), target)

        # Copy nml config change/query scripts
        safe_copy(os.path.join(src, "../scripts/atm-config-chg"), caseroot)

    create_raw_xml_file(case, caseroot)

    nmls_as_dicts = create_nml_files(case, caseroot, rundir)
    scream_input = nmls_as_dicts["data/scream_input.yaml"]

    # Create input data list
    input_data_list_file = "{}/Buildconf/scream.input_data_list".format(caseroot)
    if os.path.exists(input_data_list_file):
        os.remove(input_data_list_file)

    input_file = scream_input["Atmosphere Driver"]["Initial Conditions"]["Physics GLL"]["Filename"]
    tables     = scream_input["SCREAM"]["Input Files"]
    with open(input_data_list_file, "w") as fd:
        fd.write("ic_file = {}\n".format(input_file))
        for idx, table in enumerate(tables):
            fd.write("table_{} = {}\n".format(idx, table))

    # SCREAM is currently hardcoded to expect tables to be in data
    for table in tables:
        table_name = os.path.basename(table)
        tgt_table = os.path.join(target, table_name)
        if not os.path.exists(tgt_table) and not os.path.islink(tgt_table):
            os.symlink(table, os.path.join(target, table_name))

###############################################################################
def _main_func():
###############################################################################
    caseroot = parse_input(sys.argv)
    with Case(caseroot) as case:
        buildnml(case, caseroot, "scream")

if __name__ == "__main__":
    _main_func()
