module micro_p3_interface

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!
  !! Interface between E3SM and P3 microphysics
  !!
  !! Author: Peter Caldwell
  !!
  !! Last updated: 2018-09-12
  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  use shr_kind_mod,   only: r8=>shr_kind_r8
  use ppgrid,         only: pcols,pver,pverp

!comment: I think Kai added handle_errmsg. It would be better to 
!use standard E3SM libraries if possible.
  use error_messages, only: handle_errmsg

  use physics_types,  only: physics_state, &
                            physics_ptend, &
                            physics_ptend_init
  use physconst,      only: mwdry, cpair, mwh2o, gravit, rair, &
                            rh2o, latvap, latice, tmelt, rhoh2o, rairv 
  use constituents,   only: cnst_add, pcnst, sflxnam, apcnst, bpcnst, pcnst,&
                            cnst_name, cnst_get_ind,cnst_longname
  use physics_buffer, only: physics_buffer_desc, dtype_r8, col_type_subcol, &
                            pbuf_get_field, pbuf_add_field,dyn_time_lvls,dtype_i4, &
                            pbuf_register_subcol, pbuf_set_field, pbuf_get_index, &
                            pbuf_old_tim_idx
  use ref_pres,       only: top_lev=>trop_cloud_top_lev
  use phys_control,   only: phys_getopts, use_hetfrz_classnuc
!  use cam_debug,      only: l_debug, l_summary_debug
  use subcol_utils,   only: subcol_get_scheme
  use cam_abortutils, only: endrun
  use spmd_utils,     only: masterproc
  use cam_logfile,    only: iulog
  use time_manager,   only: is_first_step
       
  implicit none

  public :: micro_p3_init, micro_p3_register, micro_p3_tend, &
            micro_p3_init_cnst, micro_p3_implements_cnst !&
            !,micro_p3_readnl

  private

  !Define indices for state%q constituents at module level so
  !defining them in micro_p3_register makes them permanently 
  !available.
  logical :: use_subcol_microp  ! If true, then are using subcolumns in microphysics
  integer :: num_steps

  integer, public ::    &
       ixcldliq = -1,   & ! cloud liquid amount index
       ixcldice = -1,      & ! ice index
       ixnumliq = -1,   & ! cloud liquid number index
       ixnumice = -1,   & ! cloud ice number index
       ixrain   = -1,   & ! rain index
       ixnumrain= -1,   & ! rain number index
       ixcldrim = -1,      & ! rime index ??
       ixrimvol  = -1,  & ! rime volume index ??
       ixqirim  = -1      ! ?? index ??

!! pbuf 
   integer :: &
      cldo_idx,           &
      qme_idx,            &
      prain_idx,          &
      nevapr_idx,         &
      rate1_cw2pr_st_idx, &
      dei_idx,            &
      mu_idx,             &
      lambdac_idx,        &
      rei_idx,            &
      rel_idx,            &
      ls_flxprc_idx,      &
      ls_flxsnw_idx,      &
      ls_reffrain_idx,    &
      ls_reffsnow_idx,    &
      cv_reffliq_idx,     &
      cv_reffice_idx,     &
      prer_evap_idx,      &
      cmeliq_idx,         &
      relvar_idx,         &
      accre_enhan_idx,    &
      iciwpst_idx,        &
      iclwpst_idx,        &
      cc_t_idx,           &
      cc_qv_idx,          &
      cc_ql_idx,          &
      cc_qi_idx,          &
      cc_nl_idx,          &
      cc_ni_idx,          &
      cc_qlst_idx
   ! Index fields for precipitation efficiency.
   integer :: &
       acprecl_idx = -1, &
       acgcme_idx = -1, &
       acnum_idx = -1

! Physics buffer indices for fields registered by other modules
   integer :: &
      ast_idx = -1,            &
      cld_idx = -1,            &
      concld_idx = -1
! Pbuf fields needed for subcol_SILHS
   integer :: &
      qrain_idx=-1, &
      nrain_idx=-1

   integer :: &
      naai_idx = -1,           &
      naai_hom_idx = -1,       &
      npccn_idx = -1,          &
      rndst_idx = -1,          &
      nacon_idx = -1,          &
      prec_str_idx = -1,       &
      prec_pcw_idx = -1,       &
      prec_sed_idx = -1,       &
      snow_str_idx = -1,       &
      snow_pcw_idx = -1,       &
      snow_sed_idx = -1

! pbuf fields for heterogeneous freezing
   integer :: &
      frzimm_idx = -1, &
      frzcnt_idx = -1, &
      frzdep_idx = -1

! pbuf P3 specific
   integer :: &
      p3_qv_idx, &
      p3_th_idx

   logical :: &
      allow_sed_supersat  ! allow supersaturated conditions after sedimentation loop



   real(r8) :: &
      micro_mg_accre_enhan_fac = huge(1.0_r8), & !Accretion enhancement factor from namelist
      prc_coef1_in             = huge(1.0_r8), &
      prc_exp_in               = huge(1.0_r8), &
      prc_exp1_in              = huge(1.0_r8), &
      cld_sed_in               = huge(1.0_r8), & !scale fac for cloud sedimentation velocity
      nccons                   = huge(1.0_r8), &
      nicons                   = huge(1.0_r8)

   integer :: ncnst

  !Define th (potential temperature) and (water vapor mixing 
  !ratio) qv at module level so "_old" values can easily be 
  !assigned at the beginning of each step from the value at the end 
  !of the step before.

  real(r8) :: th(pcols,pver)
  real(r8) :: qv(pcols,pver)

  character(len=8), parameter :: &      ! Constituent names
     cnst_names(8) = (/'CLDLIQ', 'CLDICE','NUMLIQ','NUMICE', &
                     'RAINQM', 'CLDRIM','NUMRAI','BVRIM'/)

  real(r8) :: &             
     ice_sed_ai = 700.0_r8      ! Fall speed parameter for cloud ice

  contains
!===============================================================================
#if 0
!AaronDonahue TODO: Fix this routine to be P3 specific instead of MG specific
subroutine micro_p3_readnl(nlfile)

  use namelist_utils,  only: find_group_name
  use units,           only: getunit, freeunit
  use mpishorthand

  character(len=*), intent(in) :: nlfile  ! filepath for file containing namelist input

  ! Namelist variables
  logical :: micro_mg_do_cldice = .true. ! do_cldice = .true., MG microphysics is prognosing cldice
  logical :: micro_mg_do_cldliq = .true. ! do_cldliq = .true., MG microphysics is prognosing cldliq
  logical :: micro_do_nccons    = .false.! micro_do_nccons = .true, MG does NOT predict numliq 
  logical :: micro_do_nicons    = .false.! micro_do_nicons = .true.,MG does NOT predict numice
  integer :: micro_mg_num_steps = 1      ! Number of substepping iterations done by MG (1.5 only for now).
  real(r8) :: micro_nccons, micro_nicons

  ! Local variables
  integer :: unitn, ierr
  character(len=*), parameter :: subname = 'micro_mg_cam_readnl'

  namelist /micro_mg_nl/ micro_mg_version, micro_mg_sub_version, &
       micro_mg_do_cldice, micro_mg_do_cldliq, micro_mg_num_steps, ice_sed_ai,&
!!== KZ_DCS
       micro_mg_dcs_tdep, & 
!!== KZ_DCS
       microp_uniform, micro_mg_dcs, micro_mg_precip_frac_method, &
       micro_mg_mass_gradient_alpha, micro_mg_mass_gradient_beta, &
       micro_mg_berg_eff_factor, micro_do_nccons, micro_do_nicons, &
       micro_nccons, micro_nicons

  !-----------------------------------------------------------------------------

  if (masterproc) then
     unitn = getunit()
     open( unitn, file=trim(nlfile), status='old' )
     call find_group_name(unitn, 'micro_mg_nl', status=ierr)
     if (ierr == 0) then
        read(unitn, micro_mg_nl, iostat=ierr)
        if (ierr /= 0) then
           call endrun(subname // ':: ERROR reading namelist')
        end if
     end if
     close(unitn)
     call freeunit(unitn)

     ! set local variables
     do_cldice = micro_mg_do_cldice
     do_cldliq = micro_mg_do_cldliq
     do_nccons = micro_do_nccons
     do_nicons = micro_do_nicons
     nccons = micro_nccons
     nicons = micro_nicons
     
     num_steps = micro_mg_num_steps

  end if

#ifdef SPMD
  ! Broadcast namelist variables
  call mpibcast(micro_mg_version,            1, mpiint, 0, mpicom)
  call mpibcast(micro_mg_sub_version,        1, mpiint, 0, mpicom)
  call mpibcast(do_cldice,                   1, mpilog, 0, mpicom)
  call mpibcast(do_cldliq,                   1, mpilog, 0, mpicom)
  call mpibcast(do_nccons,                   1, mpilog, 0, mpicom)
  call mpibcast(do_nicons,                   1, mpilog, 0, mpicom)
  call mpibcast(micro_mg_dcs_tdep,           1, mpilog, 0, mpicom)
  call mpibcast(num_steps,                   1, mpiint, 0, mpicom)
  call mpibcast(microp_uniform,              1, mpilog, 0, mpicom)
  call mpibcast(micro_mg_dcs,                1, mpir8,  0, mpicom)
  call mpibcast(micro_mg_berg_eff_factor,    1, mpir8,  0, mpicom)
  call mpibcast(ice_sed_ai,                  1, mpir8,  0, mpicom)
  call mpibcast(nccons,                      1, mpir8,  0, mpicom)
  call mpibcast(nicons,                      1, mpir8,  0, mpicom)
  call mpibcast(micro_mg_precip_frac_method, 16, mpichar,0, mpicom)
  call mpibcast(micro_mg_mass_gradient_alpha, 1, mpir8, 0, mpicom)
  call mpibcast(micro_mg_mass_gradient_beta, 1, mpir8,  0, mpicom)

#endif

contains

  subroutine bad_version_endrun
    ! Endrun wrapper with a more useful error message.
    character(len=128) :: errstring
    write(errstring,*) "Invalid version number specified for MG microphysics: ", &
         micro_mg_version,".",micro_mg_sub_version
    call endrun(errstring)
  end subroutine bad_version_endrun

end subroutine micro_p3_readnl
#endif
  !================================================================================================

  subroutine micro_p3_register()

  logical :: prog_modal_aero
  logical :: save_subcol_microp ! If true, then need to store sub-columnized fields in pbuf

  if (masterproc) write(iulog,'(A20)') ' P3_REG Start'
!  if(l_summary_debug) write(6,*) 'micro_p3_register - 001 -'

   call phys_getopts(use_subcol_microp_out = use_subcol_microp, &
                    prog_modal_aero_out   = prog_modal_aero )
   ncnst = 0
    ! Register Microphysics Constituents 
    ! (i.e. members of state%q) and save indices.
    ! TODO make sure the cnst_names match what we think they are here.
    !================
   call cnst_add(cnst_names(1), mwdry, cpair, 0._r8, ixcldliq, &
         longname='Grid box averaged cloud liquid amount', &
         is_convtran1=.true.)
   ncnst = ncnst + 1
   call cnst_add(cnst_names(2), mwdry, cpair, 0._r8, ixcldice, &
         longname='Grid box averaged cloud ice amount', &
         is_convtran1=.true.)
   ncnst = ncnst + 1
   call cnst_add(cnst_names(3), mwh2o, cpair, 0._r8, ixnumliq, &
         longname='Grid box averaged cloud liquid number', &
         is_convtran1=.true.)
   ncnst = ncnst + 1
   call cnst_add(cnst_names(4), mwh2o, cpair, 0._r8, ixnumice, &
         longname='Grid box averaged cloud ice number', &
         is_convtran1=.true.)
   ncnst = ncnst + 1
   call cnst_add(cnst_names(5), mwh2o, cpair, 0._r8, ixrain, &
         longname='Grid box averaged rain amount', &
         is_convtran1=.true.)
   ncnst = ncnst + 1
   call cnst_add(cnst_names(6), mwh2o, cpair, 0._r8, ixcldrim, &
         longname='Grid box averaged riming amount', &
         is_convtran1=.true.)
   ncnst = ncnst + 1
   call cnst_add(cnst_names(7), mwh2o, cpair, 0._r8, ixnumrain, &
         longname='Grid box averaged rain number', &
         is_convtran1=.true.)
   ncnst = ncnst + 1
   call cnst_add(cnst_names(8), mwh2o, cpair, 0._r8, ixrimvol, &
         longname='Grid box averaged riming volume', &
         is_convtran1=.true.)
   ncnst = ncnst + 1
!+++ Aaron
!    call cnst_add(cnst_names(8), mwh2o, cpair, 0._r8, ixqirim, &
!         longname='Grid box averaged riming ???', &
!         is_convtran1=.true.)  ! TODO what is this?
!--- Aaron

    ! Add Variables to Pbuf
    !================
   !! P3 specific PBUF variables
   call pbuf_add_field('P3_qv','global', dtype_r8,(/pcols,pver/),p3_qv_idx)
   call pbuf_add_field('P3_th','global', dtype_r8,(/pcols,pver/),p3_th_idx)
   
   !! module microp_aero
   call pbuf_add_field('CLDO','global', dtype_r8,(/pcols,pver,dyn_time_lvls/),cldo_idx)

   !! module wetdep 
   call pbuf_add_field('QME',  'physpkg',dtype_r8,(/pcols,pver/), qme_idx)
   call pbuf_add_field('PRAIN','physpkg',dtype_r8,(/pcols,pver/), prain_idx)
   call pbuf_add_field('NEVAPR','physpkg',dtype_r8,(/pcols,pver/), nevapr_idx)

   !! module aero_model
   if (prog_modal_aero) then
      call pbuf_add_field('RATE1_CW2PR_ST','physpkg',dtype_r8,(/pcols,pver/), rate1_cw2pr_st_idx)
   endif

   !! module clubb_intr
   call pbuf_add_field('PRER_EVAP',  'global', dtype_r8,(/pcols,pver/), prer_evap_idx)

   !! module radiation_data & module cloud_rad_props
   call pbuf_add_field('DEI',        'physpkg',dtype_r8,(/pcols,pver/), dei_idx)
   call pbuf_add_field('MU',         'physpkg',dtype_r8,(/pcols,pver/), mu_idx)
   call pbuf_add_field('LAMBDAC',    'physpkg',dtype_r8,(/pcols,pver/), lambdac_idx)

   !! module cospsimulator_intr
   call pbuf_add_field('REL',        'physpkg',dtype_r8,(/pcols,pver/), rel_idx)
   call pbuf_add_field('REI',        'physpkg',dtype_r8,(/pcols,pver/), rei_idx)
   call pbuf_add_field('LS_FLXPRC',  'physpkg',dtype_r8,(/pcols,pverp/), ls_flxprc_idx)
   call pbuf_add_field('LS_FLXSNW',  'physpkg',dtype_r8,(/pcols,pverp/), ls_flxsnw_idx)
   call pbuf_add_field('LS_REFFRAIN','physpkg',dtype_r8,(/pcols,pver/), ls_reffrain_idx)
   call pbuf_add_field('LS_REFFSNOW','physpkg',dtype_r8,(/pcols,pver/), ls_reffsnow_idx)
   call pbuf_add_field('CV_REFFLIQ', 'physpkg',dtype_r8,(/pcols,pver/), cv_reffliq_idx)
   call pbuf_add_field('CV_REFFICE', 'physpkg',dtype_r8,(/pcols,pver/), cv_reffice_idx)

   !! module macrop_driver
   call pbuf_add_field('CC_T',     'global',  dtype_r8,(/pcols,pver,dyn_time_lvls/), cc_t_idx)
   call pbuf_add_field('CC_qv',    'global',  dtype_r8,(/pcols,pver,dyn_time_lvls/), cc_qv_idx)
   call pbuf_add_field('CC_ql',    'global',  dtype_r8,(/pcols,pver,dyn_time_lvls/), cc_ql_idx)
   call pbuf_add_field('CC_qi',    'global',  dtype_r8,(/pcols,pver,dyn_time_lvls/), cc_qi_idx)
   call pbuf_add_field('CC_nl',    'global',  dtype_r8,(/pcols,pver,dyn_time_lvls/), cc_nl_idx)
   call pbuf_add_field('CC_ni',    'global',  dtype_r8,(/pcols,pver,dyn_time_lvls/), cc_ni_idx)
   call pbuf_add_field('CC_qlst',  'global',  dtype_r8,(/pcols,pver,dyn_time_lvls/), cc_qlst_idx)
 
   !! (internal) Stratiform only in cloud liquid/ice water path for radiation
   call pbuf_add_field('ICLWPST',    'physpkg',dtype_r8,(/pcols,pver/),iclwpst_idx)
   call pbuf_add_field('ICIWPST',    'physpkg',dtype_r8,(/pcols,pver/),iciwpst_idx)
 
   ! Register subcolumn pbuf fields
   if (use_subcol_microp) then

     if (masterproc) write(iulog,'(A20)') '  P3_REG subcol'
     call pbuf_register_subcol('CLDO',        'micro_p3_register', cldo_idx)
     call pbuf_register_subcol('QME',         'micro_mg_cam_register', qme_idx)
     call pbuf_register_subcol('PRAIN',       'micro_mg_cam_register', prain_idx)
     call pbuf_register_subcol('NEVAPR',      'micro_mg_cam_register', nevapr_idx)
     call pbuf_register_subcol('PRER_EVAP',   'micro_p3_register', prer_evap_idx)
     call pbuf_register_subcol('DEI',         'micro_p3_register', dei_idx)
     call pbuf_register_subcol('MU',          'micro_p3_register', mu_idx)
     call pbuf_register_subcol('LAMBDAC',     'micro_p3_register', lambdac_idx)
     call pbuf_register_subcol('REL',         'micro_p3_register', rel_idx)
     call pbuf_register_subcol('REI',         'micro_p3_register', rei_idx)
     call pbuf_register_subcol('LS_FLXPRC',   'micro_p3_register', ls_flxprc_idx)
     call pbuf_register_subcol('LS_FLXSNW',   'micro_p3_register', ls_flxsnw_idx)
     call pbuf_register_subcol('LS_REFFRAIN', 'micro_p3_register', ls_reffrain_idx)
     call pbuf_register_subcol('LS_REFFSNOW', 'micro_p3_register', ls_reffsnow_idx)
     call pbuf_register_subcol('CV_REFFLIQ',  'micro_p3_register', cv_reffliq_idx)
     call pbuf_register_subcol('CV_REFFICE',  'micro_p3_register', cv_reffice_idx)
     call pbuf_register_subcol('CC_T',        'micro_p3_register', cc_t_idx)
     call pbuf_register_subcol('CC_qv',       'micro_p3_register', cc_qv_idx)
     call pbuf_register_subcol('CC_ql',       'micro_p3_register', cc_ql_idx)
     call pbuf_register_subcol('CC_qi',       'micro_p3_register', cc_qi_idx)
     call pbuf_register_subcol('CC_nl',       'micro_p3_register', cc_nl_idx)
     call pbuf_register_subcol('CC_ni',       'micro_p3_register', cc_ni_idx)
     call pbuf_register_subcol('CC_qlst',     'micro_p3_register', cc_qlst_idx)
     call pbuf_register_subcol('ICIWPST',     'micro_p3_register', iciwpst_idx)
     call pbuf_register_subcol('ICLWPST',     'micro_p3_register', iclwpst_idx)
 
     if (prog_modal_aero) then
       call pbuf_register_subcol('RATE1_CW2PR_ST', 'micro_p3_register', rate1_cw2pr_st_idx)
     end if

   end if

   !! (internal) Precipitation efficiency fields across timesteps.
   call pbuf_add_field('ACPRECL',    'global',dtype_r8,(/pcols/), acprecl_idx)! accumulated precip
   call pbuf_add_field('ACGCME',     'global',dtype_r8,(/pcols/), acgcme_idx) ! accumulated condensation
   call pbuf_add_field('ACNUM',      'global',dtype_i4,(/pcols/), acnum_idx)  ! counter for accumulated # timesteps

   !! module clubb_intr
   call pbuf_add_field('RELVAR',     'global',dtype_r8,(/pcols,pver/), relvar_idx)
   call pbuf_add_field('ACCRE_ENHAN','global',dtype_r8,(/pcols,pver/), accre_enhan_idx)

   ! Diagnostic fields needed for subcol_SILHS, need to be grid-only
   if (subcol_get_scheme() == 'SILHS') then
      call pbuf_add_field('QRAIN',   'global',dtype_r8,(/pcols,pver/), qrain_idx)
      call pbuf_add_field('NRAIN',   'global',dtype_r8,(/pcols,pver/), nrain_idx)
   end if

   if (masterproc) write(iulog,'(A20)') '    P3_REG Finished'
  end subroutine micro_p3_register

  !================================================================================================
  function micro_p3_implements_cnst(name)

    ! Return true if specified constituent is implemented by the
    ! microphysics package

    character(len=*), intent(in) :: name        ! constituent name
    logical :: micro_p3_implements_cnst    ! return value

    micro_p3_implements_cnst = any(name == cnst_names)

  end function micro_p3_implements_cnst


  !================================================================================================

  subroutine micro_p3_init_cnst(name, q, gcid)

    ! Initialize the microphysics constituents, if they are
    ! not read from the initial file.

    character(len=*), intent(in) :: name     ! constituent name
    real(r8), intent(out) :: q(:,:)   ! mass mixing ratio (gcol, plev)
    integer,  intent(in)  :: gcid(:)  ! global column id

    if (micro_p3_implements_cnst(name)) q = 0.0_r8

  end subroutine micro_p3_init_cnst

  !================================================================================================

  subroutine micro_p3_init(pbuf2d)
    use micro_p3,       only: p3_init
    use cam_history,    only: addfld, add_default, horiz_only
    use micro_p3_utils, only: micro_p3_utils_init

    type(physics_buffer_desc),  pointer :: pbuf2d(:,:)
    character(128) :: p3_lookup_dir, errstring
    integer        :: m, mm
    integer        :: ierr
    logical :: history_amwg         ! output the variables used by the AMWG diag package
    logical :: history_verbose      ! produce verbose history output
    logical :: history_budget       ! Output tendencies and state variables for CAM4
    integer :: budget_histfile      ! output history file number for budget fields
                                   ! temperature, water vapor, cloud ice and cloud

    ! PULL DIRECTORY OF LOOKUP TABLE FROM ATM NAMELIST
    ! =============
    call phys_getopts(p3_lookup_dir_out = p3_lookup_dir)

    call micro_p3_utils_init()

    ! CALL P3 INIT:
    !==============
    !might want to add all E3SM parameter vals to p3_init call...
    ast_idx      = pbuf_get_index('AST') !! from CLUBB 
    cld_idx      = pbuf_get_index('CLD') !! from CLUBB 
    concld_idx   = pbuf_get_index('CONCLD') !! from CLUBB 
    cmeliq_idx   = pbuf_get_index('CMELIQ') !! from CLUBB Rate of cond-evap of liq within the cloud

    !!
    !! for ice nucleation 
    !!

    naai_idx     = pbuf_get_index('NAAI') !! from microp 
    naai_hom_idx = pbuf_get_index('NAAI_HOM')!! from microp 
    npccn_idx    = pbuf_get_index('NPCCN')!! from microp 
    rndst_idx    = pbuf_get_index('RNDST')!! from microp 
    nacon_idx    = pbuf_get_index('NACON')!! from microp 
    frzimm_idx   = pbuf_get_index('FRZIMM', ierr) !! from microp 
    frzcnt_idx   = pbuf_get_index('FRZCNT', ierr) !! from microp 
    frzdep_idx   = pbuf_get_index('FRZDEP', ierr) !! from microp 

    prec_str_idx = pbuf_get_index('PREC_STR') !! from physpkg 
    snow_str_idx = pbuf_get_index('SNOW_STR') !! from physpkg 
    prec_sed_idx = pbuf_get_index('PREC_SED') !! from physpkg 
    snow_sed_idx = pbuf_get_index('SNOW_SED') !! from physpkg 
    prec_pcw_idx = pbuf_get_index('PREC_PCW') !! from physpkg 
    snow_pcw_idx = pbuf_get_index('SNOW_PCW') !! from physpkg 

    !! not used 
    qrain_idx    = pbuf_get_index('QRAIN', ierr) !! local 
    nrain_idx    = pbuf_get_index('NRAIN', ierr) !! local

    !TODO: add errstring and constants to init function  !DONE
    call p3_init(p3_lookup_dir)
    !call handle_errmsg(errstring, subname="micro_p3_init")

    ! Initialize physics buffer grid fields for accumulating precip and
    ! condensation
    if (is_first_step()) then


       call pbuf_set_field(pbuf2d, p3_qv_idx, 0._r8)
       call pbuf_set_field(pbuf2d, p3_th_idx, 0._r8)

       call pbuf_set_field(pbuf2d, cldo_idx,   0._r8)
       call pbuf_set_field(pbuf2d, cc_t_idx,   0._r8)
       call pbuf_set_field(pbuf2d, cc_qv_idx,  0._r8)
       call pbuf_set_field(pbuf2d, cc_ql_idx,  0._r8)
       call pbuf_set_field(pbuf2d, cc_qi_idx,  0._r8)
       call pbuf_set_field(pbuf2d, cc_nl_idx,  0._r8)
       call pbuf_set_field(pbuf2d, cc_ni_idx,  0._r8)
       call pbuf_set_field(pbuf2d, cc_qlst_idx,0._r8)
       call pbuf_set_field(pbuf2d, acprecl_idx,   0._r8)
       call pbuf_set_field(pbuf2d, acgcme_idx, 0._r8)
       call pbuf_set_field(pbuf2d, acnum_idx,  0)
       call pbuf_set_field(pbuf2d, relvar_idx, 2._r8)
       call pbuf_set_field(pbuf2d, accre_enhan_idx, micro_mg_accre_enhan_fac)
       call pbuf_set_field(pbuf2d, prer_evap_idx,  0._r8)
 
       !! not used 
       if (qrain_idx > 0)   call pbuf_set_field(pbuf2d, qrain_idx, 0._r8)
       if (nrain_idx > 0)   call pbuf_set_field(pbuf2d, nrain_idx, 0._r8)

       ! If sub-columns turned on, need to set the sub-column fields as well
       if (use_subcol_microp) then
          call pbuf_set_field(pbuf2d, cldo_idx,   0._r8, col_type=col_type_subcol)
          call pbuf_set_field(pbuf2d, cc_t_idx,   0._r8, col_type=col_type_subcol)
          call pbuf_set_field(pbuf2d, cc_qv_idx,  0._r8, col_type=col_type_subcol)
          call pbuf_set_field(pbuf2d, cc_ql_idx,  0._r8, col_type=col_type_subcol)
          call pbuf_set_field(pbuf2d, cc_qi_idx,  0._r8, col_type=col_type_subcol)
          call pbuf_set_field(pbuf2d, cc_nl_idx,  0._r8, col_type=col_type_subcol)
          call pbuf_set_field(pbuf2d, cc_ni_idx,  0._r8, col_type=col_type_subcol)
          call pbuf_set_field(pbuf2d, cc_qlst_idx,0._r8, col_type=col_type_subcol)
       end if

    end if

    ! INITIALIZE OUTPUT
    !==============
    !TODO: put addfld and add_default calls here.  !Done and testing
    do m = 1, ncnst
       call cnst_get_ind(cnst_names(m), mm)
       if ( any(mm == (/ ixcldliq, ixcldice, ixrain, ixcldrim /)) ) then
          ! mass mixing ratios
          call addfld(cnst_name(mm), (/ 'lev' /), 'A', 'kg/kg', &
            cnst_longname(mm) )
          call addfld(sflxnam(mm), horiz_only, 'A', 'kg/m2/s', &
            trim(cnst_name(mm))//' surface flux')
       else if ( any(mm == (/ ixnumliq, ixnumice, ixnumrain /)) ) then
          ! number concentrations
          call addfld(cnst_name(mm), (/ 'lev' /), 'A', '1/kg', &
            cnst_longname(mm) )
          call addfld(sflxnam(mm), horiz_only, 'A', '1/m2/s', &
            trim(cnst_name(mm))//' surface flux')
       else if ( mm == ixrimvol ) then
          ! number concentrations
          call addfld(cnst_name(mm), (/ 'lev' /), 'A', 'm3/kg', &
            cnst_longname(mm) )
          call addfld(sflxnam(mm), horiz_only, 'A', 'm3/m2/s', &
            trim(cnst_name(mm))//' surface flux')
       else
          call endrun( "micro_p3_acme_init: &
               &Could not call addfld for constituent with unknown units.")
       endif
    end do
    call addfld(apcnst(ixcldliq), (/ 'lev' /), 'A', 'kg/kg', trim(cnst_name(ixcldliq))//' after physics'  )
    call addfld(apcnst(ixcldice), (/ 'lev' /), 'A', 'kg/kg', trim(cnst_name(ixcldice))//' after physics'  )
    call addfld(bpcnst(ixcldliq), (/ 'lev' /), 'A', 'kg/kg', trim(cnst_name(ixcldliq))//' before physics' )
    call addfld(bpcnst(ixcldice), (/ 'lev' /), 'A', 'kg/kg', trim(cnst_name(ixcldice))//' before physics' )
    call addfld(apcnst(ixrain),   (/ 'lev' /), 'A', 'kg/kg', trim(cnst_name(ixrain))//' after physics'  )
    call addfld(bpcnst(ixrain),   (/ 'lev' /), 'A', 'kg/kg', trim(cnst_name(ixrain))//' before physics' )
    call addfld(apcnst(ixcldrim), (/ 'lev' /), 'A', 'kg/kg', trim(cnst_name(ixcldrim))//' after physics'  )
    call addfld(bpcnst(ixcldrim), (/ 'lev' /), 'A', 'kg/kg', trim(cnst_name(ixcldrim))//' before physics' )

    ! microphysics cloud fraction fields
    call addfld('CLOUDFRAC_LIQ_MICRO', (/ 'lev' /), 'A', 'unitless', 'Grid box liquid cloud fraction in microphysics' )
    call addfld('CLOUDFRAC_ICE_MICRO', (/ 'lev' /), 'A', 'unitless', 'Grid box ice cloud fraction in microphysics' )
    call addfld('CLOUDFRAC_RAIN_MICRO', (/ 'lev' /), 'A', 'unitless', 'Grid box rain cloud fraction in microphysics' )

    call addfld ('CME', (/ 'lev' /), 'A', 'kg/kg/s', 'Rate of cond-evap within the cloud'                      )
!    call addfld ('PRODPREC', (/ 'lev' /), 'A', 'kg/kg/s', 'Rate of conversion of condensate to precip'              )
!    call addfld ('EVAPPREC', (/ 'lev' /), 'A', 'kg/kg/s', 'Rate of evaporation of falling precip'                   )
!    call addfld ('EVAPSNOW', (/ 'lev' /), 'A', 'kg/kg/s', 'Rate of evaporation of falling snow'                     )
!    call addfld ('HPROGCLD', (/ 'lev' /), 'A', 'W/kg'    , 'Heating from prognostic clouds'                          )
    call addfld ('FICE', (/ 'lev' /), 'A', 'fraction', 'Fractional ice content within cloud'                     )
    call addfld ('ICWMRST', (/ 'lev' /), 'A', 'kg/kg', 'Prognostic in-stratus water mixing ratio'                )
    call addfld ('ICIMRST', (/ 'lev' /), 'A', 'kg/kg', 'Prognostic in-stratus ice mixing ratio'                  )

   ! MG microphysics diagnostics
!    call addfld ('QCSEVAP', (/ 'lev' /), 'A', 'kg/kg/s', 'Rate of evaporation of falling cloud water'              )
!    call addfld ('QISEVAP', (/ 'lev' /), 'A', 'kg/kg/s', 'Rate of sublimation of falling cloud ice'                )
!    call addfld ('QVRES', (/ 'lev' /), 'A', 'kg/kg/s', 'Rate of residual condensation term'                      )
    call addfld ('CMEIOUT', (/ 'lev' /), 'A', 'kg/kg/s', 'Rate of deposition/sublimation of cloud ice'             )
!    call addfld ('VTRMC', (/ 'lev' /), 'A', 'm/s', 'Mass-weighted cloud water fallspeed'                     )
!    call addfld ('VTRMI', (/ 'lev' /), 'A', 'm/s', 'Mass-weighted cloud ice fallspeed'                       )
    call addfld ('QCSEDTEN', (/ 'lev' /), 'A', 'kg/kg/s', 'Cloud water mixing ratio tendency from sedimentation'    )
    call addfld ('QISEDTEN', (/ 'lev' /), 'A', 'kg/kg/s', 'Cloud ice mixing ratio tendency from sedimentation'      )
!    call addfld ('PRAO', (/ 'lev' /), 'A', 'kg/kg/s', 'Accretion of cloud water by rain'                        )
!    call addfld ('PRCO', (/ 'lev' /), 'A', 'kg/kg/s', 'Autoconversion of cloud water'                           )
!    call addfld ('MNUCCCO', (/ 'lev' /), 'A', 'kg/kg/s', 'Immersion freezing of cloud water'                       )
!    call addfld ('MNUCCTO', (/ 'lev' /), 'A', 'kg/kg/s', 'Contact freezing of cloud water'                         )
!    call addfld ('MNUCCDO', (/ 'lev' /), 'A', 'kg/kg/s', 'Homogeneous and heterogeneous nucleation from vapor'     )
!    call addfld ('MNUCCDOhet', (/ 'lev' /), 'A','kg/kg/s', 'Heterogeneous nucleation from vapor'                     )
!    call addfld ('MSACWIO', (/ 'lev' /), 'A', 'kg/kg/s', 'Conversion of cloud water from rime-splintering'         )
!    call addfld ('PSACWSO', (/ 'lev' /), 'A', 'kg/kg/s', 'Accretion of cloud water by snow'                        )
!    call addfld ('BERGSO', (/ 'lev' /), 'A', 'kg/kg/s', 'Conversion of cloud water to snow from bergeron'         )
!    call addfld ('BERGO', (/ 'lev' /), 'A', 'kg/kg/s', 'Conversion of cloud water to cloud ice from bergeron'    )
!    call addfld ('MELTO', (/ 'lev' /), 'A', 'kg/kg/s', 'Melting of cloud ice'                                    )
!    call addfld ('HOMOO', (/ 'lev' /), 'A', 'kg/kg/s', 'Homogeneous freezing of cloud water'                     )
!    call addfld ('QCRESO', (/ 'lev' /), 'A', 'kg/kg/s', 'Residual condensation term for cloud water'              )
!    call addfld ('PRCIO', (/ 'lev' /), 'A', 'kg/kg/s', 'Autoconversion of cloud ice'                             )
!    call addfld ('PRAIO', (/ 'lev' /), 'A', 'kg/kg/s', 'Accretion of cloud ice by rain'                          )
!    call addfld ('QIRESO', (/ 'lev' /), 'A', 'kg/kg/s', 'Residual deposition term for cloud ice'                  )
!    call addfld ('MNUCCRO', (/ 'lev' /), 'A', 'kg/kg/s', 'Heterogeneous freezing of rain to snow'                  )
!    call addfld ('PRACSO', (/ 'lev' /), 'A', 'kg/kg/s', 'Accretion of rain by snow'                               )
!    call addfld ('MELTSDT', (/ 'lev' /), 'A', 'W/kg', 'Latent heating rate due to melting of snow'              )
!    call addfld ('FRZRDT', (/ 'lev' /), 'A', 'W/kg', 'Latent heating rate due to homogeneous freezing of rain' )
   call addfld ('QRSEDTEN', (/ 'lev' /), 'A', 'kg/kg/s', 'Rain mixing ratio tendency from sedimentation'           )
!    call addfld ('QSSEDTEN', (/ 'lev' /), 'A', 'kg/kg/s', 'Snow mixing ratio tendency from sedimentation'           )

   ! History variables for CAM5 microphysics
!    call addfld ('MPDT', (/ 'lev' /), 'A', 'W/kg', 'Heating tendency - Morrison microphysics'                )
!    call addfld ('MPDQ', (/ 'lev' /), 'A', 'kg/kg/s', 'Q tendency - Morrison microphysics'                      )
!    call addfld ('MPDLIQ', (/ 'lev' /), 'A', 'kg/kg/s', 'CLDLIQ tendency - Morrison microphysics'                 )
!    call addfld ('MPDICE', (/ 'lev' /), 'A', 'kg/kg/s', 'CLDICE tendency - Morrison microphysics'                 )
!    call addfld ('MPDW2V', (/ 'lev' /), 'A', 'kg/kg/s', 'Water <--> Vapor tendency - Morrison microphysics'       )
!    call addfld ('MPDW2I', (/ 'lev' /), 'A', 'kg/kg/s', 'Water <--> Ice tendency - Morrison microphysics'         )
!    call addfld ('MPDW2P', (/ 'lev' /), 'A', 'kg/kg/s', 'Water <--> Precip tendency - Morrison microphysics'      )
!    call addfld ('MPDI2V', (/ 'lev' /), 'A', 'kg/kg/s', 'Ice <--> Vapor tendency - Morrison microphysics'         )
!    call addfld ('MPDI2W', (/ 'lev' /), 'A', 'kg/kg/s', 'Ice <--> Water tendency - Morrison microphysics'         )
!    call addfld ('MPDI2P', (/ 'lev' /), 'A', 'kg/kg/s', 'Ice <--> Precip tendency - Morrison microphysics'        )
    call addfld ('ICWNC', (/ 'lev' /), 'A', 'm-3', 'Prognostic in-cloud water number conc'                   )
    call addfld ('ICINC', (/ 'lev' /), 'A', 'm-3', 'Prognostic in-cloud ice number conc'                     )
!    call addfld ('EFFLIQ_IND', (/ 'lev' /), 'A','Micron', 'Prognostic droplet effective radius (indirect effect)'   )
    call addfld ('CDNUMC', horiz_only,    'A', '1/m2', 'Vertically-integrated droplet concentration'             )
    call addfld ('MPICLWPI', horiz_only,    'A', 'kg/m2', 'Vertically-integrated &
         &in-cloud Initial Liquid WP (Before Micro)' )
    call addfld ('MPICIWPI', horiz_only,    'A', 'kg/m2', 'Vertically-integrated &
         &in-cloud Initial Ice WP (Before Micro)'    )

   ! This is provided as an example on how to write out subcolumn output
   ! NOTE -- only 'I' should be used for sub-column fields as subc-columns could shift from time-step to time-step
!   if (use_subcol_microp) then
!      call addfld('FICE_SCOL', (/'psubcols','lev     '/), 'I', 'fraction', &
!           'Sub-column fractional ice content within cloud', flag_xyfill=.true., fill_value=1.e30_r8)
!   end if

   ! Averaging for cloud particle number and size
   call addfld ('AWNC', (/ 'lev' /), 'A', 'm-3', 'Average cloud water number conc'                         )
   call addfld ('AWNI', (/ 'lev' /), 'A', 'm-3', 'Average cloud ice number conc'                           )
   call addfld ('AREL', (/ 'lev' /), 'A', 'Micron', 'Average droplet effective radius'                        )
   call addfld ('AREI', (/ 'lev' /), 'A', 'Micron', 'Average ice effective radius'                            )
   ! Frequency arrays for above
   call addfld ('FREQL', (/ 'lev' /), 'A', 'fraction', 'Fractional occurrence of liquid'                          )
   call addfld ('FREQI', (/ 'lev' /), 'A', 'fraction', 'Fractional occurrence of ice'                             )

   ! Average cloud top particle size and number (liq, ice) and frequency
!   call addfld ('ACTREL', horiz_only,    'A', 'Micron', 'Average Cloud Top droplet effective radius'              )
!   call addfld ('ACTREI', horiz_only,    'A', 'Micron', 'Average Cloud Top ice effective radius'                  )
!   call addfld ('ACTNL', horiz_only,    'A', 'Micron', 'Average Cloud Top droplet number'                        )
!   call addfld ('ACTNI', horiz_only,    'A', 'Micron', 'Average Cloud Top ice number'                            )

!   call addfld ('FCTL', horiz_only,    'A', 'fraction', 'Fractional occurrence of cloud top liquid'                )
!   call addfld ('FCTI', horiz_only,    'A', 'fraction', 'Fractional occurrence of cloud top ice'                   )

!   call addfld ('LS_FLXPRC', (/ 'ilev' /), 'A', 'kg/m2/s', 'ls stratiform gbm interface rain+snow flux')
!   call addfld ('LS_FLXSNW', (/ 'ilev' /), 'A', 'kg/m2/s', 'ls stratiform gbm interface snow flux')

   call addfld ('REL', (/ 'lev' /), 'A', 'micron', 'MG REL stratiform cloud effective radius liquid')
   call addfld ('REI', (/ 'lev' /), 'A', 'micron', 'MG REI stratiform cloud effective radius ice')
!   call addfld ('LS_REFFRAIN', (/ 'lev' /), 'A', 'micron', 'ls stratiform rain effective radius')
!   call addfld ('LS_REFFSNOW', (/ 'lev' /), 'A', 'micron', 'ls stratiform snow effective radius')
!   call addfld ('CV_REFFLIQ', (/ 'lev' /), 'A', 'micron', 'convective cloud liq effective radius')
!   call addfld ('CV_REFFICE', (/ 'lev' /), 'A', 'micron', 'convective cloud ice effective radius')

!!== KZ_DCS
   call addfld ('DCST',(/ 'lev' /), 'A','m','dcs')
!!== KZ_DCS
   ! diagnostic precip
   call addfld ('QRAIN',(/ 'lev' /), 'A','kg/kg','Diagnostic grid-mean rain mixing ratio'         )
   call addfld ('QSNOW',(/ 'lev' /), 'A','kg/kg','Diagnostic grid-mean snow mixing ratio'         )
   call addfld ('NRAIN',(/ 'lev' /), 'A','m-3','Diagnostic grid-mean rain number conc'         )
   call addfld ('NSNOW',(/ 'lev' /), 'A','m-3','Diagnostic grid-mean snow number conc'         )

   ! size of precip
!   call addfld ('RERCLD',(/ 'lev' /), 'A','m','Diagnostic effective radius of Liquid Cloud and Rain' )
!   call addfld ('DSNOW',(/ 'lev' /), 'A','m','Diagnostic grid-mean snow diameter'         )

   ! diagnostic radar reflectivity, cloud-averaged
!   call addfld ('REFL',(/ 'lev' /), 'A','DBz','94 GHz radar reflectivity'       )
!   call addfld ('AREFL',(/ 'lev' /), 'A','DBz','Average 94 GHz radar reflectivity'       )
!   call addfld ('FREFL',(/ 'lev' /), 'A','fraction','Fractional occurrence of radar reflectivity'       )

!   call addfld ('CSRFL',(/ 'lev' /), 'A','DBz','94 GHz radar reflectivity (CloudSat thresholds)'       )
!   call addfld ('ACSRFL',(/ 'lev' /), 'A','DBz','Average 94 GHz radar reflectivity (CloudSat thresholds)'       )
!   call addfld ('FCSRFL',(/ 'lev' /), 'A','fraction','Fractional occurrence of radar reflectivity (CloudSat thresholds)' &
!        )

!   call addfld ('AREFLZ',(/ 'lev' /), 'A','mm^6/m^3','Average 94 GHz radar reflectivity'       )

   ! Aerosol information
   call addfld ('NCAL',(/ 'lev' /), 'A','1/m3','Number Concentation Activated for Liquid')
   call addfld ('NCAI',(/ 'lev' /), 'A','1/m3','Number Concentation Activated for Ice')

   ! Average rain and snow mixing ratio (Q), number (N) and diameter (D), with frequency
   call addfld ('AQRAIN',(/ 'lev' /), 'A','kg/kg','Average rain mixing ratio'         )
   call addfld ('AQSNOW',(/ 'lev' /), 'A','kg/kg','Average snow mixing ratio'         )
   call addfld ('ANRAIN',(/ 'lev' /), 'A','m-3','Average rain number conc'         )
   call addfld ('ANSNOW',(/ 'lev' /), 'A','m-3','Average snow number conc'         )
   call addfld ('ADRAIN',(/ 'lev' /), 'A','Micron','Average rain effective Diameter'         )
   call addfld ('ADSNOW',(/ 'lev' /), 'A','Micron','Average snow effective Diameter'         )
   call addfld ('FREQR',(/ 'lev' /), 'A','fraction','Fractional occurrence of rain'       )
   call addfld ('FREQS',(/ 'lev' /), 'A','fraction','Fractional occurrence of snow'       )

   ! precipitation efficiency & other diagnostic fields
!   call addfld('PE'    ,       horiz_only, 'A', '1', 'Stratiform Precipitation Efficiency  (precip/cmeliq)' )
!   call addfld('APRL'  ,     horiz_only, 'A', 'm/s', 'Average Stratiform Precip Rate over efficiency calculation' )
!   call addfld('PEFRAC',       horiz_only, 'A', '1', 'Fraction of timesteps precip efficiency reported' )
!   call addfld('VPRCO' , horiz_only, 'A', 'kg/kg/s', 'Vertical average of autoconversion rate' )
!   call addfld('VPRAO' , horiz_only, 'A', 'kg/kg/s', 'Vertical average of accretion rate' )
!   call addfld('RACAU' , horiz_only, 'A', 'kg/kg/s', 'Accretion/autoconversion ratio from vertical average' )

   call addfld('UMR', (/ 'lev' /), 'A',   'm/s', 'Mass-weighted rain  fallspeed'              )
!      call addfld('UMS', (/ 'lev' /), 'A',   'm/s', 'Mass-weighted snow fallspeed'               )

   ! qc limiter (only output in versions 1.5 and later)
!   if (.not. (micro_mg_version == 1 .and. micro_mg_sub_version == 0)) then
!      call addfld('QCRAT', (/ 'lev' /), 'A', 'fraction', 'Qc Limiter: Fraction of qc tendency applied')
!   end if

   ! determine the add_default fields
   call phys_getopts(history_amwg_out           = history_amwg         , &
                     history_verbose_out        = history_verbose      , &
                     history_budget_out         = history_budget       , &
                     history_budget_histfile_num_out = budget_histfile)
   if (history_amwg) then
      call add_default ('FICE    ', 1, ' ')
      call add_default ('AQRAIN   ', 1, ' ')
      call add_default ('AQSNOW   ', 1, ' ')
      call add_default ('ANRAIN   ', 1, ' ')
      call add_default ('ANSNOW   ', 1, ' ')
      if (history_verbose) then
         call add_default ('ADRAIN   ', 1, ' ')
         call add_default ('ADSNOW   ', 1, ' ')
      endif
      call add_default ('AREI     ', 1, ' ')
      call add_default ('AREL     ', 1, ' ')
      call add_default ('AWNC     ', 1, ' ')
      call add_default ('AWNI     ', 1, ' ')
      call add_default ('CDNUMC   ', 1, ' ')
      call add_default ('FREQR    ', 1, ' ')
      call add_default ('FREQS    ', 1, ' ')
      call add_default ('FREQL    ', 1, ' ')
      call add_default ('FREQI    ', 1, ' ')
      do m = 1, ncnst
         call cnst_get_ind(cnst_names(m), mm)
         call add_default(cnst_name(mm), 1, ' ')
         ! call add_default(sflxnam(mm),   1, ' ')
      end do
      ! Microphysics cloud fractions
      call add_default ('CLOUDFRAC_LIQ_MICRO', 1, ' ')
      call add_default ('CLOUDFRAC_ICE_MICRO', 1, ' ')
      call add_default ('CLOUDFRAC_RAIN_MICRO', 1, ' ')
   end if

  end subroutine micro_p3_init

  !================================================================================================

  subroutine micro_p3_tend(state, ptend, dtime, pbuf)

    use cam_history,    only: outfld
    use physics_buffer, only: pbuf_col_type_index
    use micro_p3,       only: p3_main
    use micro_p3_utils, only: size_dist_param_basic, &
                              size_dist_param_liq, &
                              mg_liq_props, &
                              mg_ice_props, &
                              avg_diameter, &
                              rhoi, &
                              rhosn, &
                              rhow, &
                              rhows, &
                              qsmall, &
                              mincld

    !INPUT/OUTPUT VARIABLES
    type(physics_state),         intent(in)    :: state
    type(physics_ptend),         intent(out)   :: ptend
    real(r8),                    intent(in)    :: dtime
    type(physics_buffer_desc),   pointer       :: pbuf(:)
    logical :: lq(pcnst)   !list of what constituents to update

    !INTERNAL VARIABLES
    real(r8), pointer :: th_old(:,:)     !potential temperature from last step   K
    real(r8), pointer :: qv_old(:,:)     !water vapor from last step             kg/kg
    real(r8) :: ssat(pcols,pver)       !supersaturated mixing ratio            kg/kg
    real(r8) :: dzq(pcols,pver)        !geometric layer thickness              m
    real(r8) :: cldliq(pcols,pver)     !cloud liquid water mixing ratio        kg/kg
    real(r8) :: numliq(pcols,pver)     !cloud liquid water drop concentraiton  #/kg
    real(r8) :: rain(pcols,pver)       !rain water mixing ratio                kg/kg
    real(r8) :: numrain(pcols,pver)    !rain water number concentration        #/kg
    real(r8) :: qv(pcols,pver)         !water vapor mixing ratio               kg/kg
    real(r8) :: ice(pcols,pver)        !total ice water mixing ratio           kg/kg
    real(r8) :: qirim(pcols,pver)      !rime ice mixing ratio                  kg/kg
    real(r8) :: numice(pcols,pver)     !total ice crystal number concentration #/kg
    real(r8) :: rimvol(pcols,pver)     !rime volume mixing ratio               m3/kg
    real(r8) :: temp(pcols,pver)       !potential temperature                  K
    real(r8) :: rim(pcols,pver)        !rime mixing ratio                      kg/kg
    real(r8) :: prt_liq(pcols)         !precipitation rate, liquid             m s-1
    real(r8) :: prt_sol(pcols)         !precipitation rate, solid              m s-1
    real(r8) :: diag_ze(pcols,pver)    !equivalent reflectivity                dBZ
    real(r8) :: diag_effc(pcols,pver)  !effective radius, cloud                m
    real(r8) :: diag_effi(pcols,pver)  !effective radius, ice                  m
    real(r8) :: diag_vmi(pcols,pver)   !mass-weighted fall speed of ice        m s-1
    real(r8) :: diag_di(pcols,pver)    !mean diameter of ice                   m
    real(r8) :: diag_rhoi(pcols,pver)  !bulk density of ice                    kg m-1
    real(r8) :: pres(pcols,pver)       !pressure at midlevel                   hPa
    real(r8) :: cmeiout(pcols,pver)
    real(r8) :: rflx(pcols,pver+1)     !grid-box average rain flux (kg m^-2s^-1) pverp
    real(r8) :: sflx(pcols,pver+1)     !grid-box average ice/snow flux (kg m^-2s^-1) pverp
    real(r8) :: exner(pcols,pver)      !exner formula for converting between potential and normal temp
    real(r8) :: rcldm(pcols,pver)      !rain cloud fraction
    real(r8) :: lcldm(pcols,pver)      !liquid cloud fraction
    real(r8) :: icldm(pcols,pver)      !ice cloud fraction

    ! PBUF Variables
    real(r8), pointer :: ast(:,:)      ! Relative humidity cloud fraction
    real(r8), pointer :: cld(:,:)          ! Total cloud fraction
    real(r8), pointer :: concld(:,:)       ! Convective cloud fraction
    real(r8), pointer :: naai(:,:)      ! ice nucleation number
    real(r8), pointer :: naai_hom(:,:)  ! ice nucleation number (homogeneous)
    real(r8), pointer :: npccn(:,:)     ! liquid activation number tendency
    real(r8), pointer :: rndst(:,:,:)
    real(r8), pointer :: nacon(:,:,:)
    real(r8), pointer :: cmeliq(:,:)
    !! variables for heterogeneous freezing
    real(r8), pointer :: frzimm(:,:)
    real(r8), pointer :: frzcnt(:,:)
    real(r8), pointer :: frzdep(:,:)
    !!
    real(r8), pointer :: prec_str(:)          ! [Total] Sfc flux of precip from stratiform [ m/s ]
    real(r8), pointer :: prec_sed(:)          ! Surface flux of total cloud water from sedimentation
    real(r8), pointer :: prec_pcw(:)          ! Sfc flux of precip from microphysics [ m/s ]
    real(r8), pointer :: snow_str(:)          ! [Total] Sfc flux of snow from stratiform   [ m/s ]
    real(r8), pointer :: snow_pcw(:)          ! Sfc flux of snow from microphysics [ m/s ]
    real(r8), pointer :: snow_sed(:)          ! Surface flux of cloud ice from sedimentation
    real(r8), pointer :: relvar(:,:)       ! relative variance of cloud water
    real(r8), pointer :: accre_enhan(:,:)  ! optional accretion enhancement for experimentation
    real(r8), pointer :: cldo(:,:)         ! Old cloud fraction
    real(r8), pointer :: prer_evap(:,:)    ! precipitation evaporation rate 
    !! wetdep 
    real(r8), pointer :: qme(:,:)
    real(r8), pointer :: prain(:,:)        ! Total precipitation (rain + snow)
    real(r8), pointer :: nevapr(:,:)       ! Evaporation of total precipitation (rain + snow)
    !! COSP simulator
    real(r8), pointer :: rel(:,:)          ! Liquid effective drop radius (microns)
    real(r8), pointer :: rei(:,:)          ! Ice effective drop size (microns)
    real(r8), pointer :: flxprc(:,:)     ! P3 grid-box mean flux_large_scale_cloud_rain+snow at interfaces (kg/m2/s)
    real(r8), pointer :: flxsnw(:,:)     ! P3 grid-box mean flux_large_scale_cloud_snow at interfaces (kg/m2/s)
    real(r8), pointer :: reffrain(:,:)   ! P3 diagnostic rain effective radius (um)
    real(r8), pointer :: reffsnow(:,:)   ! P3 diagnostic snow effective radius (um)
    real(r8), pointer :: cvreffliq(:,:)    ! convective cloud liquid effective radius (um)
    real(r8), pointer :: cvreffice(:,:)    ! convective cloud ice effective radius (um)

    real(r8), pointer :: iciwpst(:,:)      ! Stratiform in-cloud ice water path for radiation
    real(r8), pointer :: iclwpst(:,:)      ! Stratiform in-cloud liquid water path for radiation
    !! radiation 
    real(r8), pointer :: dei(:,:)          ! Ice effective diameter (um)
    real(r8), pointer :: mu(:,:)           ! Size distribution shape parameter for radiation
    real(r8), pointer :: lambdac(:,:)      ! Size distribution slope parameter for radiation
    !! Park-Macro
    real(r8), pointer :: cc_t(:,:)
    real(r8), pointer :: cc_qv(:,:)
    real(r8), pointer :: cc_ql(:,:)
    real(r8), pointer :: cc_qi(:,:)
    real(r8), pointer :: cc_nl(:,:)
    real(r8), pointer :: cc_ni(:,:)
    real(r8), pointer :: cc_qlst(:,:)
    !!
    real(r8), pointer, dimension(:) :: acprecl ! accumulated precip across timesteps
    real(r8), pointer, dimension(:) :: acgcme  ! accumulated condensation across timesteps
    integer,  pointer, dimension(:) :: acnum   ! counter for # timesteps accumulated
    ! DONE PBUF

    ! Derived Variables
    real(r8) :: tgliqwp(pcols)   ! column liquid
    real(r8) :: tgcmeliq(pcols)  ! column condensation rate (units)
    real(r8) :: pe(pcols)        ! precip efficiency for output
    real(r8) :: pefrac(pcols)    ! fraction of time precip efficiency is written out
    real(r8) :: tpr(pcols)       ! average accumulated precipitation rate in pe calculation
    real(r8) :: icimrst(pcols,pver) ! stratus ice mixing ratio - on grid
    real(r8) :: icwmrst(pcols,pver) ! stratus water mixing ratio - on grid
    real(r8) :: rho(pcols,pver)
    real(r8) :: icecldf(state%psetcols,pver) ! Ice cloud fraction
    real(r8) :: liqcldf(state%psetcols,pver) ! Liquid cloud fraction (combined into cloud)
    real(r8) :: ncic(pcols,pver)
    real(r8) :: niic(pcols,pver)
    real(r8) :: rel_fn(pcols,pver)    ! Ice effective drop size at fixed number (indirect effect) (microns) - on grid
    real(r8) :: nc(pcols,pver)
    real(r8) :: drout2(pcols,pver)
    real(r8) :: reff_rain(pcols,pver)

    ! Variables used for microphysics output
    real(r8) :: aqrain(pcols,pver)
    real(r8) :: anrain(pcols,pver)
    real(r8) :: nfice(pcols,pver)
    real(r8) :: efcout(pcols,pver)      
    real(r8) :: efiout(pcols,pver)      
    real(r8) :: ncout(pcols,pver)      
    real(r8) :: niout(pcols,pver)      
    real(r8) :: freqr(pcols,pver)      
    real(r8) :: freql(pcols,pver)      
    real(r8) :: freqi(pcols,pver)      
    real(r8) :: cdnumc(pcols)      
    real(r8) :: icwmrst_out(pcols,pver) 
    real(r8) :: icimrst_out(pcols,pver) 
    real(r8) :: icinc(pcols,pver) 
    real(r8) :: icwnc(pcols,pver) 

 
    integer :: it                      !timestep counter                       -
    integer :: its, ite                !horizontal bounds (column start,finish)
    integer :: kts                     !closest level to TOM                   -
    integer :: kte                     !near surface level                     -

    logical :: log_predictNc           !prognostic droplet concentration or not?
    integer :: col_type ! Flag to store whether accessing grid or sub-columns in pbuf_get_field
    integer :: icol, ncol, k
    integer :: psetcols, lchnk
    integer :: itim_old
    integer :: ngrdcol

    ! For rrtmg optics. specified distribution.
    real(r8), parameter :: dcon   = 25.e-6_r8         ! Convective size distribution effective radius (um)
    real(r8), parameter :: mucon  = 5.3_r8            ! Convective size distribution shape parameter
    real(r8), parameter :: deicon = 50._r8            ! Convective ice effective diameter (um)

    ! For potential temperature conversion
    real(r8) :: rd, cp, inv_cp

    psetcols = state%psetcols
    lchnk = state%lchnk
    ngrdcol  = state%ngrdcol

    !+++ Aaron Donahue
    itim_old = pbuf_old_tim_idx()
    call phys_getopts(use_subcol_microp_out=use_subcol_microp)
    call pbuf_col_type_index(use_subcol_microp, col_type=col_type)

    !============================ 
    ! All external PBUF variables:
    ! INPUTS
    call pbuf_get_field(pbuf, ast_idx,         ast,     start=(/1,1,itim_old/), kount=(/psetcols,pver,1/), &
         col_type=col_type, copy_if_needed=use_subcol_microp)
    call pbuf_get_field(pbuf, cld_idx,         cld,     start=(/1,1,itim_old/), kount=(/psetcols,pver,1/), &
         col_type=col_type, copy_if_needed=use_subcol_microp)
    call pbuf_get_field(pbuf, concld_idx,      concld,  start=(/1,1,itim_old/), kount=(/psetcols,pver,1/), &
         col_type=col_type, copy_if_needed=use_subcol_microp)  ! Not used
    call pbuf_get_field(pbuf, naai_idx,        naai,        col_type=col_type, copy_if_needed=use_subcol_microp) ! Not used in this ver of P3
    call pbuf_get_field(pbuf, naai_hom_idx,    naai_hom,    col_type=col_type, copy_if_needed=use_subcol_microp) ! Not used
    call pbuf_get_field(pbuf, npccn_idx,       npccn,       col_type=col_type, copy_if_needed=use_subcol_microp) ! Not used in this ver of P3
    call pbuf_get_field(pbuf, rndst_idx,       rndst,       col_type=col_type, copy_if_needed=use_subcol_microp) ! Not used in this ver of P3
    call pbuf_get_field(pbuf, nacon_idx,       nacon,       col_type=col_type, copy_if_needed=use_subcol_microp) ! Not used in this ver of P3
    call pbuf_get_field(pbuf, cmeliq_idx,      cmeliq,      col_type=col_type, copy_if_needed=use_subcol_microp)
    if (use_hetfrz_classnuc) then ! Not used in this ver of P3 
       call pbuf_get_field(pbuf, frzimm_idx, frzimm, col_type=col_type, copy_if_needed=use_subcol_microp)
       call pbuf_get_field(pbuf, frzcnt_idx, frzcnt, col_type=col_type, copy_if_needed=use_subcol_microp)
       call pbuf_get_field(pbuf, frzdep_idx, frzdep, col_type=col_type, copy_if_needed=use_subcol_microp)
    end if
    ! OUTPUTS
    call pbuf_get_field(pbuf,    prec_str_idx,  prec_str,    col_type=col_type)
    call pbuf_get_field(pbuf,    snow_str_idx,  snow_str,    col_type=col_type)
    call pbuf_get_field(pbuf,    prec_sed_idx,  prec_sed,    col_type=col_type)
    call pbuf_get_field(pbuf,    snow_sed_idx,  snow_sed,    col_type=col_type)
    call pbuf_get_field(pbuf,    prec_pcw_idx,  prec_pcw,    col_type=col_type)
    call pbuf_get_field(pbuf,    snow_pcw_idx,  snow_pcw,    col_type=col_type)
    !============================ 
    ! All internal PBUF variables
    ! INPUTS
    call pbuf_get_field(pbuf, relvar_idx,      relvar,      col_type=col_type, copy_if_needed=use_subcol_microp) ! Not used in this ver of P3
    call pbuf_get_field(pbuf, accre_enhan_idx, accre_enhan, col_type=col_type, copy_if_needed=use_subcol_microp) ! Not used in this ver of P3
    ! P3 SPECIFIC
    call pbuf_get_field(pbuf, p3_qv_idx, qv_old) 
    call pbuf_get_field(pbuf, p3_th_idx, th_old) 
    ! OUTPUTS
    call pbuf_get_field(pbuf,        cldo_idx,      cldo,     start=(/1,1,itim_old/), kount=(/psetcols,pver,1/), col_type=col_type)
    call pbuf_get_field(pbuf,         qme_idx,       qme,    col_type=col_type)
    call pbuf_get_field(pbuf,       prain_idx,     prain,    col_type=col_type)
    call pbuf_get_field(pbuf,      nevapr_idx,    nevapr,    col_type=col_type)
    call pbuf_get_field(pbuf,   prer_evap_idx, prer_evap,    col_type=col_type)
    !call pbuf_get_field(pbuf,       wsedl_idx,     wsedl,    col_type=col_type) 
    call pbuf_get_field(pbuf,         rei_idx,       rei,    col_type=col_type) ! ice eff. rad
    call pbuf_get_field(pbuf,         rel_idx,       rel,    col_type=col_type) ! liq. eff. rad
    call pbuf_get_field(pbuf,         dei_idx,       dei,    col_type=col_type)
    call pbuf_get_field(pbuf,          mu_idx,        mu,    col_type=col_type)
    call pbuf_get_field(pbuf,     lambdac_idx,   lambdac,    col_type=col_type)
    call pbuf_get_field(pbuf,     iciwpst_idx,   iciwpst,    col_type=col_type)
    call pbuf_get_field(pbuf,     iclwpst_idx,   iclwpst,    col_type=col_type)
    !call pbuf_get_field(pbuf,         des_idx,       des,    col_type=col_type) 
    !call pbuf_get_field(pbuf,       icswp_idx,     icswp,    col_type=col_type) 
    !call pbuf_get_field(pbuf,    cldfsnow_idx,  cldfsnow,    col_type=col_type) 
    call pbuf_get_field(pbuf,   ls_flxprc_idx,    flxprc,    col_type=col_type)
    call pbuf_get_field(pbuf,   ls_flxsnw_idx,    flxsnw,    col_type=col_type)
    !call pbuf_get_field(pbuf,   ls_mrprc_idx,    flxsnw,    col_type=col_type)
    !call pbuf_get_field(pbuf,   ls_mrsnw_idx,    flxsnw,    col_type=col_type)
    call pbuf_get_field(pbuf, ls_reffrain_idx,  reffrain                      ) 
    call pbuf_get_field(pbuf, ls_reffsnow_idx,  reffsnow                      ) 
    call pbuf_get_field(pbuf,  cv_reffliq_idx, cvreffliq,    col_type=col_type)
    call pbuf_get_field(pbuf,  cv_reffice_idx, cvreffice,    col_type=col_type)
    call pbuf_get_field(pbuf, cc_t_idx,        cc_t,     start=(/1,1,itim_old/), kount=(/psetcols,pver,1/), col_type=col_type)
    call pbuf_get_field(pbuf, cc_qv_idx,       cc_qv,    start=(/1,1,itim_old/), kount=(/psetcols,pver,1/), col_type=col_type)
    call pbuf_get_field(pbuf, cc_ql_idx,       cc_ql,    start=(/1,1,itim_old/), kount=(/psetcols,pver,1/), col_type=col_type)
    call pbuf_get_field(pbuf, cc_qi_idx,       cc_qi,    start=(/1,1,itim_old/), kount=(/psetcols,pver,1/), col_type=col_type)
    call pbuf_get_field(pbuf, cc_nl_idx,       cc_nl,    start=(/1,1,itim_old/), kount=(/psetcols,pver,1/), col_type=col_type)
    call pbuf_get_field(pbuf, cc_ni_idx,       cc_ni,    start=(/1,1,itim_old/), kount=(/psetcols,pver,1/), col_type=col_type)
    call pbuf_get_field(pbuf, cc_qlst_idx,     cc_qlst,  start=(/1,1,itim_old/), kount=(/psetcols,pver,1/), col_type=col_type)
    !call pbuf_get_field(pbuf,   tnd_qsnow_idx, tnd_qsnow,    col_type=col_type) 
    !call pbuf_get_field(pbuf,   tnd_nsnow_idx, tnd_nsnow,    col_type=col_type) 
    !call pbuf_get_field(pbuf,      re_ice_idx,    re_ice,    col_type=col_type) 
    call pbuf_get_field(pbuf,     acprecl_idx,   acprecl                       ) 
    call pbuf_get_field(pbuf,      acgcme_idx,    acgcme                       ) 
    call pbuf_get_field(pbuf,       acnum_idx,     acnum                       ) 
    !call pbuf_get_field(pbuf,       qrain_idx,     qrain,    col_type=col_type) 
    !call pbuf_get_field(pbuf,       qsnow_idx,     qsnow,    col_type=col_type) 
    !call pbuf_get_field(pbuf,       nrain_idx,     nrain,    col_type=col_type) 
    !call pbuf_get_field(pbuf,       nsnow_idx,     nsnow,    col_type=col_type) 

    
    rd = rair  ! Probably not needed now that we are using Exner
    cp = cpair ! Probably not needed now that we are using Exner
    inv_cp = 1./cp ! Dido from above
    
    ncol = state%ncol
    !==============
    ! Some pre-microphysics INITIALIZATION
    !==============
    cldo(:ncol,top_lev:pver)=ast(:ncol,top_lev:pver)
    ! INITIALIZE PTEND
    !==============
    !ptend is an output variable. Since not substepping in micro, don't need 
    !a local copy.

    lq            = .false. !initialize all constituents to false.
    lq(1)         = .true.
    lq(ixcldliq)  = .true.
    lq(ixcldice)  = .true.
    lq(ixnumliq)  = .true.
    lq(ixnumice)  = .true.
    lq(ixrain)    = .true.
    lq(ixcldrim)  = .true.
    lq(ixnumrain) = .true.
    lq(ixrimvol)  = .true.

    call physics_ptend_init(ptend, psetcols, "micro_p3", ls=.true., lq=lq)

    ! HANDLE AEROSOL ACTIVATION
    !==============
    !saving this for later... use prescribed Nd for now.
    log_predictNc = .false.

    ! GET "OLD" VALUES
    !==============
    ! TODO: answer question: is_first_step =1 for each submission, or just for type=initial first step?
    !          does p3 want _old values from last p3 call, or from some other point?
    ! TODO: Determine what is needed for restarts.  For example, should qv_old
    ! and th_old be added to the pbuf so that they are written and loaded with
    ! each restart?
    ! Aaron- is_first_step=1 only for first step of initial run, per:
    !      logical function is_first_step()
    !              Return true on first step of initial run only.
    do icol = 1,ncol
       do k = 1,pver
          exner(icol,k) = 1._r8/((state%pmid(icol,k)*1.e-5)**(rd*inv_cp))
          if ( is_first_step() ) then
             th_old(icol,k)=state%t(icol,k)*exner(icol,k) !/(state%pmid(icol,k)*1.e-5)**(rd*inv_cp)
             qv_old(icol,k)=state%q(icol,k,1)
!          else
!             th_old(icol,k) = th(icol,k) !use th from end of last p3 step
!             qv_old(icol,k) = qv(icol,k) !use qv from end of last p3 step
          end if
       end do
    end do

    ! CONVERT T TO POTENTIAL TEMPERATURE
    !==============
    ! Someday we may want to make P3 take in T rather than theta... it uses both.


    ! COMPUTE GEOMETRIC THICKNESS OF GRID
    !==============
    do icol = 1,ncol
       do k = 1,pver
! Note: dzq is calculated in the opposite direction that pdel is calculated,
! thus when considering any dp/dz calculation we must also change the sign.
          dzq(icol,k) = state%zi(icol,k) - state%zi(icol,k+1)
          th(icol,k)  = state%t(icol,k)*exner(icol,k) !/(state%pmid(icol,k)*1.e-5)**(rd*inv_cp) 
       end do
    end do

    ! ASSIGN TOP AND BOTTOM INDICES FOR GRID
    !==============
    !kts is closest level to top of model. Instead of 1 (top-of-model), 
    !we use the previously-defined trop_cloud_top_lev to reduce the number of 
    !levels we need to calculate and to avoid upper-atmos regions where this
    !micro-physics is inappropriate. kte is the near-surface level = pver.

    kts=top_lev
    kte=pver 

    ! DEAL WITH SSAT
    !==============
    !ssat (supersaturated mixing ratio measured in kg/kg) can be prognosed
    !or diagnosed in p3 depending on p3's hardcoded log_predictSsat parameter.
    !ssat is an intent inout variable, but when log_predictSsat is false 
    !(as we will set it initially), ssat is overwritten rather than used by p3.
    !Thus it shouldn't matter what ssat is, so we give it -999.

    ssat(:,:) = -999._r8

    ! HANDLE TIMESTEP COUNTER
    !==============
    !p3 wants to know the timestep number (which it calls "it") because it
    !handles things differently on the first step, where it doesn't have values
    !yet. E3SM has a handy function for deciding if this is the first step, so 
    !we hack "it" with "is_first_step()" for now. Eventually, we should replace
    !"it" with a logical.

    if (is_first_step()) then
       it=1
    else
       it=999 !integer
    end if

    ! MAKE LOCAL COPIES OF VARS MODIFIED BY P3
    !==============
    !local copies are needed because state is passed into this routine as intent=in
    !while P3 seeks to modify state variables in-place. Also, we need a copy of 
    !old values in order to back out ptend values later. Traditionally, a local copy 
    !is created by copying the whole state. It is much cheaper to just copy the 
    !variables we need. 
    
    cldliq  = state%q(:,:,ixcldliq)
    numliq  = state%q(:,:,ixnumliq)
    rain    = state%q(:,:,ixrain)
    numrain = state%q(:,:,ixnumrain)
    qv      = state%q(:,:,1)
    ice     = state%q(:,:,ixcldice)
    qirim   = state%q(:,:,ixcldrim) !Aaron, changed ixqirim to ixcldrim to match Kai's code
    numice  = state%q(:,:,ixnumice)
    rimvol  = state%q(:,:,ixrimvol)
    its     = 1
    ite     = state%ncol
    kts     = 1
    kte     = pver
    pres    = state%pmid(:,:)
    ! CALL P3
    !==============
#if 1
    ! TODO: get proper value for 'it' from time module
    call p3_main( &
         cldliq(its:ite,kts:kte),     & ! INOUT  cloud, mass mixing ratio         kg kg-1
         numliq(its:ite,kts:kte),     & ! INOUT  cloud, number mixing ratio       #  kg-1
         rain(its:ite,kts:kte),       & ! INOUT  rain, mass mixing ratio          kg kg-1
         numrain(its:ite,kts:kte),    & ! INOUT  rain, number mixing ratio        #  kg-1
         th_old(its:ite,kts:kte),     & ! INOUT  beginning of time step theta     K
         th(its:ite,kts:kte),         & ! INOUT  potential temperature            K
         qv_old(its:ite,kts:kte),     & ! INOUT  beginning of time step qv        kg kg-1
         qv(its:ite,kts:kte),         & ! INOUT  water vapor mixing ratio         kg kg-1
         dtime,                       & ! IN     model time step                  s
         ice(its:ite,kts:kte),        & ! INOUT  ice, total mass mixing ratio     kg kg-1
         qirim(its:ite,kts:kte),      & ! INOUT  ice, rime mass mixing ratio      kg kg-1
         numice(its:ite,kts:kte),     & ! INOUT  ice, total number mixing ratio   #  kg-1
         rimvol(its:ite,kts:kte),     & ! INOUT  ice, rime volume mixing ratio    m3 kg-1
         ssat(its:ite,kts:kte),       & ! INOUT  supersaturation (i.e., qv-qvs)   kg kg-1
         pres(its:ite,kts:kte),       & ! IN     pressure at cell midpoints       Pa
         dzq(its:ite,kts:kte),        & ! IN     vertical grid spacing            m
         it,                          & ! IN     time step counter NOTE: starts at 1 for first time step
         prt_liq(its:ite),            & ! OUT    surface liquid precip rate       m s-1
         prt_sol(its:ite),            & ! OUT    surface frozen precip rate       m s-1
         its,                         & ! IN     horizontal index lower bound     -
         ite,                         & ! IN     horizontal index upper bound     -
         kts,                         & ! IN     vertical index lower bound       -
         kte,                         & ! IN     vertical index upper bound       -
         diag_ze(its:ite,kts:kte),    & ! OUT    equivalent reflectivity          dBZ  UNUSED?
         rel(its:ite,kts:kte),        & ! OUT    effective radius, cloud          m
         rei(its:ite,kts:kte),        & ! OUT    effective radius, ice            m
         diag_vmi(its:ite,kts:kte),   & ! OUT    mass-weighted fall speed of ice  m s-1
         diag_di(its:ite,kts:kte),    & ! OUT    mean diameter of ice             m
         diag_rhoi(its:ite,kts:kte),  & ! OUT    bulk density of ice              kg m-1
         log_predictNc,               & ! IN     .true.=prognostic Nc, .false.=specified Nc
         ! AaronDonahue new stuff
         state%pdel(its:ite,kts:kte), & ! IN pressure level thickness for computing total mass
         exner(its:ite,kts:kte), & ! IN exner values
         ast(its:ite,kts:kte),        & ! IN relative humidity cloud fraction
         cmeiout(its:ite,kts:kte),    & ! OUT Deposition/sublimation rate of cloud ice 
         prain(its:ite,kts:kte),      & ! OUT Total precipitation (rain + snow)
         nevapr(its:ite,kts:kte),     & ! OUT evaporation of total precipitation (rain + snow)
         prer_evap(its:ite,kts:kte),  & ! OUT rain evaporation
         rflx(its:ite,kts:kte+1),     & ! OUT grid-box average rain flux (kg m^-2s^-1) pverp 
         sflx(its:ite,kts:kte+1),     & ! OUT grid-box average ice/snow flux (kgm^-2 s^-1) pverp
         rcldm(its:ite,kts:kte),      & ! OUT rain cloud fraction
         lcldm(its:ite,kts:kte),      & ! OUT liquid cloud fraction
         icldm(its:ite,kts:kte)       & ! OUT ice cloud fraction
         )

    ! UPDATE TH AND QV OLD FOR NEXT P3 STEP
    do icol = 1,ncol
       do k = 1,pver
          th_old(icol,k) = th(icol,k) !use th from end of last p3 step
          qv_old(icol,k) = qv(icol,k) !use qv from end of last p3 step
       end do
    end do

    !MASSAGE OUTPUT TO FIT E3SM EXPECTATIONS
    !============= 
!    precl=prt_liq+prt_sol

    !TODO: figure out what else other E3SM parameterizations need from micro and make sure 
    !they are assigned here. The comments below are a step in that direction.

    !cloud_rad_props needs ice effective diameter, which Kai calculates as below:
    !   dei = rei*diag_rhopo(i,k,iice)/rhows*2._r8
    !where rhopo is bulk ice density from table lookup (taken from f1pr16, but not 
    !done in my ver yet) and rhows=917.0 is a constant parameter.

    !cloud_rad_props also uses snow radiative properties which aren't available from 
    !P3 (perhaps because ice phase in p3 includes *all* ice already?).

    !BACK OUT TENDENCIES FROM STATE CHANGES
    !=============
    !Aaron, imbed these calls inside do loops to avoid a series of "floating
    ! invalid" error messages at runtime
    do icol = 1,ncol
       do k = 1,pver
          temp(icol,k) = th(icol,k)/exner(icol,k) !*(state%pmid(icol,k)*1.e-5)**(rd*inv_cp) !convert theta to 
          ptend%s(icol,k)           = cpair*(temp(icol,k) - state%t(icol,k))/dtime ! changed cpair to 1005
          ptend%q(icol,k,1)         = (max(0._r8,qv(icol,k)     ) - state%q(icol,k,1) )/dtime
          ptend%q(icol,k,ixcldliq)  = (max(0._r8,cldliq(icol,k) ) - state%q(icol,k,ixcldliq) )/dtime
          ptend%q(icol,k,ixnumliq)  = (max(0._r8,numliq(icol,k) ) - state%q(icol,k,ixnumliq) )/dtime
          ptend%q(icol,k,ixrain)    = (max(0._r8,rain(icol,k)   ) - state%q(icol,k,ixrain) )/dtime
          ptend%q(icol,k,ixnumrain) = (max(0._r8,numrain(icol,k)) - state%q(icol,k,ixnumrain) )/dtime
          ptend%q(icol,k,ixcldice)  = (max(0._r8,ice(icol,k)    ) - state%q(icol,k,ixcldice) )/dtime
          ptend%q(icol,k,ixnumice)  = (max(0._r8,numice(icol,k) ) - state%q(icol,k,ixnumice) )/dtime
          ptend%q(icol,k,ixcldrim)  = (max(0._r8,rim(icol,k)    ) - state%q(icol,k,ixcldrim) )/dtime
          ptend%q(icol,k,ixrimvol)  = (max(0._r8,rimvol(icol,k) ) - state%q(icol,k,ixrimvol) )/dtime

       end do
    end do
#endif

    ! Net micro_p3 condensation rate
    qme(:ncol,top_lev:pver) = cmeliq(:ncol,top_lev:pver) + cmeiout(:ncol,top_lev:pver)  ! cmeiout is output from p3 micro

    ! For precip, accumulate only total precip in prec_pcw and snow_pcw variables.
    ! Other precip output variables are set to 0
    ! Do not subscript by ncol here, because in physpkg we divide the whole
    ! array and need to avoid an FPE due to uninitialized data.
    prec_pcw = prt_liq + prt_sol
    prec_sed = 0._r8
    prec_str = prec_pcw + prec_sed

    snow_pcw = prt_sol
    snow_sed = 0._r8
    snow_str = snow_pcw + snow_sed
      
   !icecldf(:ncol,top_lev:pver) = ast(:ncol,top_lev:pver)
   !liqcldf(:ncol,top_lev:pver) = ast(:ncol,top_lev:pver) ! already an output from p3_main
      
   ! ------------------------------------------------------------ !
   ! Compute in cloud ice and liquid mixing ratios                !
   ! Note that 'iclwp, iciwp' are used for radiation computation. !
   ! ------------------------------------------------------------ !
      
   icinc = 0._r8
   icwnc = 0._r8
   iciwpst = 0._r8
   iclwpst = 0._r8
      
   do k = top_lev, pver
      do icol = 1, ncol
         ! Limits for in-cloud mixing ratios consistent with P3 microphysics
         ! in-cloud mixing ratio maximum limit of 0.005 kg/kg
         icimrst(icol,k)   = min( state%q(icol,k,ixcldice) / max(mincld,icldm(icol,k)),0.005_r8 )
         icwmrst(icol,k)   = min( state%q(icol,k,ixcldliq) / max(mincld,lcldm(icol,k)),0.005_r8 )
         icinc(icol,k)     = state%q(icol,k,ixnumice) / max(mincld,icldm(icol,k)) * &
              state%pmid(icol,k) / (287.15_r8*state%t(icol,k))
         icwnc(icol,k)     = state%q(icol,k,ixnumliq) / max(mincld,lcldm(icol,k)) * &
              state%pmid(icol,k) / (287.15_r8*state%t(icol,k))
         ! Calculate micro_p3_acme cloud water paths in each layer
         ! Note: uses stratiform cloud fraction!
         iciwpst(icol,k)   = min(state%q(icol,k,ixcldice)/max(mincld,ast(icol,k)),0.005_r8) * state%pdel(icol,k) / gravit
         iclwpst(icol,k)   = min(state%q(icol,k,ixcldliq)/max(mincld,ast(icol,k)),0.005_r8) * state%pdel(icol,k) / gravit
      end do                    
   end do
  
   ! array must be zeroed beyond trop_cloud_top_pre otherwise undefined values will be used in cosp.
   flxprc(:ncol,1:top_lev) = 0.0_r8
   flxsnw(:ncol,1:top_lev) = 0.0_r8

   flxprc(:ncol,top_lev:pverp) = rflx(:ncol,top_lev:pverp) + sflx(:ncol,top_lev:pverp) ! need output from p3
   flxsnw(:ncol,top_lev:pverp) = sflx(:ncol,top_lev:pverp) ! need output from p3
    !note s=cp*T has units J/kg

   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   !!
   !! derived fields 
   !!
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   

   ! Calculate rho (on subcolumns if turned on) for size distribution
   ! parameter calculations and average it if needed
   !
   ! State instead of state_loc to preserve answers for P31 (and in any
   ! case, it is unlikely to make much difference).
   
   rho(:ncol,top_lev:) = &
      state%pmid(:ncol,top_lev:) / (rair*state%t(:ncol,top_lev:))

   !!
   !! Effective radius for cloud liquid, fixed number.
   !!
   
   mu = 0._r8
   lambdac = 0._r8
   rel_fn = 10._r8

   ncic = 1.e8_r8

   !! size distribution 
   
   call size_dist_param_liq( &
                             mg_liq_props, &
                             icwmrst(:ngrdcol,top_lev:), &
                             ncic   (:ngrdcol,top_lev:), &
                             rho         (:ngrdcol,top_lev:), &
                             mu     (:ngrdcol,top_lev:), &
                             lambdac(:ngrdcol,top_lev:))

   where (icwmrst(:ngrdcol,top_lev:) > qsmall)
      rel_fn(:ngrdcol,top_lev:) = &
                    (mu(:ngrdcol,top_lev:) + 3._r8)/ &
                    lambdac(:ngrdcol,top_lev:)/2._r8 * 1.e6_r8
   end where

   !!
   !! Effective radius for cloud liquid, and size parameters
   !! mu and lambdac.
   !!
   
   mu = 0._r8
   lambdac = 0._r8
   rel = 10._r8

   !!
   !! Calculate ncic on the grid
   !!
   
   ncic(:ngrdcol,top_lev:) = nc(:ngrdcol,top_lev:) / &
        max(mincld,lcldm(:ngrdcol,top_lev:))

   call size_dist_param_liq(&
           mg_liq_props, &
           icwmrst(:ngrdcol,top_lev:), & 
           ncic(:ngrdcol,top_lev:), &
           rho(:ngrdcol,top_lev:), &
           mu(:ngrdcol,top_lev:), &
           lambdac(:ngrdcol,top_lev:))

   where (icwmrst(:ngrdcol,top_lev:) >= qsmall)
      rel(:ngrdcol,top_lev:) = &
           (mu(:ngrdcol,top_lev:) + 3._r8) / &
           lambdac(:ngrdcol,top_lev:)/2._r8 * 1.e6_r8
   elsewhere
      ! Deal with the fact that size_dist_param_liq sets mu to -100
      ! wherever there is no cloud.
      mu(:ngrdcol,top_lev:) = 0._r8
   end where

   !!
   !! Rain/Snow effective diameter
   !!
   
   drout2    = 0._r8
   reff_rain = 0._r8
   aqrain    = 0._r8
   anrain    = 0._r8
   freqr     = 0._r8

      ! Prognostic precipitation

      where (rain(:ngrdcol,top_lev:) >= 1.e-7_r8)
         drout2(:ngrdcol,top_lev:) = avg_diameter( &
              rain(:ngrdcol,top_lev:), &
              numrain(:ngrdcol,top_lev:) * rho(:ngrdcol,top_lev:), &
              rho(:ngrdcol,top_lev:), rhow)

         aqrain = rain * rcldm
         anrain = numrain * rcldm
         freqr = rcldm
         reff_rain(:ngrdcol,top_lev:) = drout2(:ngrdcol,top_lev:) * &
              1.5_r8 * 1.e6_r8
      end where


   !!
   !! Effective radius and diameter for cloud ice
   !!
   
   rei = 25._r8

   niic(:ngrdcol,top_lev:) = numice(:ngrdcol,top_lev:) / &
        max(mincld,icldm(:ngrdcol,top_lev:))

   call size_dist_param_basic( &
           mg_ice_props, &
           icimrst(:ngrdcol,top_lev:), &
           niic(:ngrdcol,top_lev:), &
           rei(:ngrdcol,top_lev:))

   where (icimrst(:ngrdcol,top_lev:) >= qsmall)
      rei(:ngrdcol,top_lev:) = &
         1.5_r8/rei(:ngrdcol,top_lev:) * 1.e6_r8
   elsewhere
      rei(:ngrdcol,top_lev:) = 25._r8
   end where

   dei = rei * rhoi/rhows * 2._r8

   !!
   !! Limiters for low cloud fraction
   !!
   
   do k = top_lev, pver
      do icol = 1, ngrdcol
         if ( ast(icol,k) < 1.e-4_r8 ) then
            mu(icol,k) = mucon
            lambdac(icol,k) = (mucon + 1._r8)/dcon
            dei(icol,k) = deicon
         end if
      end do
   end do

   reffrain(:ngrdcol,top_lev:pver) = reff_rain(:ngrdcol,top_lev:pver)
   reffsnow(:ngrdcol,top_lev:pver) = 1000._r8 !! dummy value 

   ! ------------------------------------- !
   ! Precipitation efficiency Calculation  !
   ! ------------------------------------- !

   !-----------------------------------------------------------------------
   ! Liquid water path

   ! Compute liquid water paths, and column condensation
   tgliqwp(:ngrdcol) = 0._r8
   tgcmeliq(:ngrdcol) = 0._r8
   do k = top_lev, pver
      do icol = 1, ngrdcol
         tgliqwp(icol)  = tgliqwp(icol) + iclwpst(icol,k)*cld(icol,k)

         if (cmeliq(icol,k) > 1.e-12_r8) then
            !convert cmeliq to right units:  kgh2o/kgair/s  *  kgair/m2  / kgh2o/m3  = m/s
            tgcmeliq(icol) = tgcmeliq(icol) + cmeliq(icol,k) * &
                 (state%pdel(icol,k) / gravit) / rhoh2o
         end if
      end do
   end do

   ! Averaging for new output fields
   efcout      = 0._r8
   efiout      = 0._r8
   ncout       = 0._r8
   niout       = 0._r8
   freql       = 0._r8
   freqi       = 0._r8
   cdnumc      = 0._r8
   icwmrst_out = 0._r8
   icimrst_out = 0._r8
   nfice       = 0._r8

   ! FICE
   where (ice .gt. qsmall .and. (rain+ice+cldliq) .gt. qsmall)
      nfice=min(ice/(rain+ice+cldliq),1._r8)
   elsewhere
      nfice=0._r8
   end where

   ! Column droplet concentration
   cdnumc(:ngrdcol) = sum(nc(:ngrdcol,top_lev:pver) * &
        state%pdel(:ngrdcol,top_lev:pver)/gravit, dim=2)
   do k = top_lev, pver
      do icol = 1, ngrdcol
         if ( lcldm(icol,k) > 0.01_r8 .and. icwmrst(icol,k) > 5.e-5_r8 ) then
            efcout(icol,k) = rel(icol,k) * lcldm(icol,k)
            ncout(icol,k)  = icwnc(icol,k) * lcldm(icol,k)
            freql(icol,k)  = lcldm(icol,k)
            icwmrst_out(icol,k) = icwmrst(icol,k)
         end if
         if ( icldm(icol,k) > 0.01_r8 .and. icimrst(icol,k) > 1.e-6_r8 ) then
            efiout(icol,k) = rei(icol,k) * icldm(icol,k)
            niout(icol,k)  = icinc(icol,k) * icldm(icol,k)
            freqi(icol,k)  = icldm(icol,k)
            icimrst_out(icol,k) = icimrst(icol,k)
         end if
      end do
   end do

   ! note: 1e-6 kgho2/kgair/s * 1000. pa / (9.81 m/s2) / 1000 kgh2o/m3 = 1e-7 m/s
   ! this is 1ppmv of h2o in 10hpa
   ! alternatively: 0.1 mm/day * 1.e-4 m/mm * 1/86400 day/s = 1.e-9

    !WRITE OUTPUT
    !=============
   call outfld('AQRAIN',      aqrain,      psetcols, lchnk, avg_subcol_field=use_subcol_microp)
   call outfld('ANRAIN',      anrain,      psetcols, lchnk, avg_subcol_field=use_subcol_microp)
   call outfld('AREL',        efcout,      pcols, lchnk)
!   call outfld('AREI',        efiout,      pcols, lchnk) ! AaronDonahue, This seems to lead to NaN in output, need to check this out 
   call outfld('AWNC' ,       ncout,       pcols, lchnk)
   call outfld('AWNI' ,       niout,       pcols, lchnk)
   call outfld('FICE',        nfice,       psetcols, lchnk, avg_subcol_field=use_subcol_microp)
   call outfld('FREQL',       freql,       pcols, lchnk)
   call outfld('FREQI',       freqi,       pcols, lchnk)
   call outfld('FREQR',       freqr,       psetcols, lchnk, avg_subcol_field=use_subcol_microp)
   call outfld('CDNUMC',      cdnumc,      pcols, lchnk)

   call outfld('CLOUDFRAC_LIQ_MICRO', lcldm,      pcols, lchnk)
   call outfld('CLOUDFRAC_ICE_MICRO', icldm,      pcols, lchnk)
   call outfld('CLOUDFRAC_RAIN_MICRO', rcldm,      pcols, lchnk)

! P3 doesn't have snow
!   call outfld('FREQS',       freqs,       psetcols, lchnk, avg_subcol_field=use_subcol_microp)
!   call outfld('ANSNOW',      nsout2,      psetcols, lchnk, avg_subcol_field=use_subcol_microp)
!   call outfld('AQSNOW',      qsout2,      psetcols, lchnk, avg_subcol_field=use_subcol_microp)
    
    !call outfld('P3_QCAUT',   qcaut,  pcols, lchnk)


  end subroutine micro_p3_tend

  !================================================================================================

end module micro_p3_interface
